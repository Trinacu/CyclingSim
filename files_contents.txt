include/appstate.h
```
// include/appstate.h
#ifndef APPSTATE_H
#define APPSTATE_H

#include "sim.h"
#include "texturemanager.h" // For GameResources
#include <SDL3/SDL.h>
#include <chrono>
#include <thread>

// Forward declarations
class ScreenManager;

class AppState {
public:
  // Constants
  const int SCREEN_WIDTH = 1000;
  const int SCREEN_HEIGHT = 640;

  const int FPS = 60;

  // Core Hardware/SDL Resources (Owned by AppState)
  SDL_Window* window = nullptr;
  SDL_Renderer* renderer = nullptr;

  std::chrono::steady_clock::time_point last_frame_time;

  // Logic & Assets (Owned by AppState)
  GameResources* resources = nullptr;
  Course* course = nullptr;
  Simulation* sim = nullptr;
  std::thread* physics_thread = nullptr;

  // View State
  ScreenManager* screens;

  AppState();
  ~AppState();

  bool load_image(const char* id, const char* filename);

  // Helper to get window size dynamically if needed
  Vector2d get_window_size() const {
    return Vector2d(SCREEN_WIDTH, SCREEN_HEIGHT);
  }
};

#endif
```

include/camera.h
```
#ifndef CAMERA_H
#define CAMERA_H

#include "course.h"
#include "snapshot.h"
#include <optional>

class Camera {
public:
  Camera(const Course* course, int world_width, Vector2d screensize);

  // --- Transformations ---
  Vector2d world_to_screen(Vector2d world) const;
  MatrixX2d world_to_screen(MatrixX2d world) const;
  Vector2d screen_to_world(Vector2d screen) const;

  // --- Follow logic ---
  void set_target_id(int rider_uid);
  void clear_target();
  bool has_target() const { return target_uid.has_value(); }

  // Update camera position each frame
  void update(const InterpolatedFrameView& view);

  // --- Manual controls ---
  void pan(double dx, double dy); // screen space delta
  void zoom(double amount);       // amount > 0 zooms in
                                  //
  double get_scale() { return scale; }

  // Direct set (used rarely)
  void set_center(Vector2d p) { pos = p; }

  // Accessors
  Vector2d get_pos() const { return pos; }

private:
  const Course* course;
  const int world_width;
  Vector2d screensize;

  double scale;      // pixels per meter
  double vert_scale; //  additional vertical scaling

  Vector2d pos; // world coordinate camera center
  std::optional<int> target_uid;

  // smooth follow parameters
  double follow_strength = 0.4; // 0=no follow, 1=teleport
};

#endif
```

include/corerenderer.h
```
#ifndef CORE_RENDERER_H
#define CORE_RENDERER_H

#include <SDL3/SDL.h>
#include <memory>
#include <vector>

class GameResources;
class Drawable;

// The fundamental UI-only renderer.
// This draws only 2D/UI Drawables; no camera, no simulation, no world-space.
class CoreRenderer {
public:
  CoreRenderer(SDL_Renderer* renderer, GameResources* resources);
  virtual ~CoreRenderer() = default;

  // Add/remove UI drawables
  void add_drawable(std::unique_ptr<Drawable> d);
  void clear_drawables();

  // The main render entry point (screens call this)
  virtual void render_frame();

  SDL_Renderer* sdl() const { return renderer; }
  GameResources* get_resources() const { return resources; }

protected:
  SDL_Renderer* renderer;   // Raw pointer; owned by AppState
  GameResources* resources; // Raw pointer; owned by AppState
  std::vector<std::unique_ptr<Drawable>> drawables;
};

#endif
```

include/course.h
```
// course.h
#ifndef COURSE_H
#define COURSE_H

#include "pch.hpp"
#include <iostream>

struct Wind {
  double heading;
  double speed;
};

struct Segment {
  double start_x;
  double length;
  double slope;
  double end_x;
  double heading;

  double altitude_at(double x) const { return slope * (x - start_x); }
};

std::ostream& operator<<(std::ostream& os, const Segment& seg);

class ICourseView {
public:
  virtual double get_slope(double pos) const = 0;
  virtual double get_altitude(double pos) const = 0;
  virtual Wind get_wind(double pos) const = 0;
  // virtual bool isCheckpoint(double pos) const = 0;
  virtual ~ICourseView() = default;
};

class Course : public ICourseView {
private:
  std::vector<Segment> segments;
  std::vector<double> altitudes; // y at each segment start

public:
  double total_length;

  std::vector<Vector2d> visual_points;

  Course(const std::vector<std::array<double, 3>> segments);
  static Course
  from_segments(const std::vector<std::array<double, 3>> segments);

  double get_altitude(double pos) const override;
  double get_slope(double pos) const override;
  Wind get_wind(double pos) const override;

  int find_segment(double pos) const;

  MatrixX2d get_points(double x_min, double x_max) const;

  static Course create_flat();
  static Course create_endulating();

  void print();
};
#endif
```

include/display.h
```
// display.h
#ifndef DISPLAY_H
#define DISPLAY_H

#include "camera.h"
#include "course.h"
#include "snapshot.h"
#include "texturemanager.h"
#include "visualmodel.h"
#include <memory>

#include <SDL3/SDL.h>

struct RenderContext {
  SDL_Renderer* renderer;
  std::weak_ptr<Camera> camera_weak;
  ResourceProvider* resources;
  double sim_time;

  const FrameSnapshot* prev_frame = nullptr;
  const FrameSnapshot* curr_frame = nullptr;

  InterpolatedFrameView view;

  double alpha = 1.0; // 0 ... 1

  const RiderSnapshot* get_snapshot(const size_t id) const {
    auto it = curr_frame->riders.find(id);
    if (it != curr_frame->riders.end())
      return &it->second;
    return nullptr;
  }
};

enum class RenderLayer : int { Course = 0, Riders = 1, UI = 2, COUNT };

class Drawable {
public:
  virtual RenderLayer layer() const = 0;
  // Called each frame; the implementer draws itself with the given SDL_Renderer
  virtual void render(const RenderContext* ctx) = 0;
  virtual bool handle_event(const SDL_Event* e) { return false; }
  virtual ~Drawable() = default;
  virtual void render_imgui(const RenderContext* ctx) {} // NEW: default empty
};

class CourseDrawable : public Drawable {
private:
  const Course* course;

public:
  CourseDrawable(const Course* course_);
  RenderLayer layer() const override { return RenderLayer::Course; }

  void render(const RenderContext* ctx) override;
};

struct RiderVisualState {
  double wheel_angle = 0.0;                         // radians
  double anim_phase = std::rand() * 1.0 / RAND_MAX; // 0..1 for sprite animation

  double last_pos = std::numeric_limits<double>::quiet_NaN();
  double last_anim_sim_time = std::numeric_limits<double>::quiet_NaN();
};

class RiderDrawable : public Drawable {
  std::unordered_map<int, RiderVisualState> visuals;
  const RiderVisualModel& model = ROAD_BIKE_VISUAL;

public:
  RiderDrawable() = default;
  RenderLayer layer() const override { return RenderLayer::Riders; }

  void render(const RenderContext* ctx) override;
};

#endif
```

include/helpers.h
```
struct SDL_Surface;
struct SDL_Texture;
struct SDL_Renderer;

void convert_color(SDL_Surface* surf);

SDL_Surface* load_transparent_bmp(const char* filename);
SDL_Texture* load_from_file(SDL_Renderer* renderer, const char* filename);
```

include/mytypes.h
```
```

include/pch.hpp
```
// pch.hpp
#ifndef PCH_HPP
#define PCH_HPP

#include <Eigen/Core> // Minimal Eigen header
// Add other common headers here
//
using Vector2d = Eigen::RowVector2d;
using MatrixX2d = Eigen::MatrixX2d;
using MatrixX3d = Eigen::MatrixX3d;

#endif // PCH_HPP
```

include/plotrenderer.h
```
#ifndef PLOT_RENDERER_H
#define PLOT_RENDERER_H

#include "corerenderer.h"

class PlotRenderer : public CoreRenderer {
public:
  PlotRenderer(SDL_Renderer* r, GameResources* res);

  void render_frame() override;

  bool handle_event(const SDL_Event* e);

private:
  void render_plot_imgui();
};

#endif
```

include/rider.h
```
// rider.h
#ifndef RIDER_H
#define RIDER_H

#include "course.h"
#include "snapshot.h"
#include "texturemanager.h"
#include "visualmodel.h"
#include <SDL3/SDL.h>
#include <iostream>

struct SDL_Texture;

class Team {
private:
public:
  std::string name;
  Team(const char* name_);

  int id;
};

class Bike {
public:
  double mass;
  double wheel_i;
  double wheel_r;
  double wheel_drag_factor;
  double crr;
  double dt_loss;
  BikeType type;

  Bike(double mass_, double wheel_i_, double wheel_r_,
       double wheel_drag_factor_, double crr_, double dt_loss_, BikeType type_);
  static Bike create_generic();
};

class Rider {
private:
  static size_t global_id_counter; // declaration
  const size_t uid;                // unique ID
  double ftp_base;
  double effort;
  double max_effort;
  double cda;
  double cda_factor;
  double effective_cda;
  double mass;
  double total_mass;
  double heading = 0;
  double v_hw;
  Vector2d _pos2d = Vector2d{0, 0};

  double power;

  double drag_coeff;
  double roll_coeff;
  double inertia_coeff;
  double f_grav;
  double slope;
  double mass_ir;

  double timestep;

  Bike bike;
  Team team;
  TextureManager* tex_manager;
  const ICourseView* course;

  void set_cda_factor(double cda_factor_);
  void set_mass(double total_mass_);

  void update_power_breakdown(double old_speed);

  std::array<double, (int)PowerTerm::COUNT> power_breakdown;

public:
  std::string name;
  double target_effort;
  double pos = 0.0;
  double altitude = 0.0;
  double speed;
  const SDL_Texture* image;

  Rider(std::string name_, double ftp_base_, double mass_, double cda_,
        Bike bike_, Team team_);
  static Rider* create_generic(Team team_);

  void set_course(const ICourseView* cv);

  RiderSnapshot snapshot() const;

  void change_bike(Bike bike_);

  void reset();
  void update(double dt);

  size_t get_id() const { return uid; }

  void set_effort(double new_effort);

  double km() const;
  double km_h() const;

  Vector2d get_pos2d() const;
  void set_pos2d(Vector2d pos);

  double pow_speed(double new_speed);
  double pow_speed_prime(double new_speed) const;
  double pow_speed_double_prime(double new_speed) const;

  void compute_drag();
  void compute_roll();
  void compute_inertia();
  void compute_coeff();
  void compute_headwind();

  double newton(double power, double speed_guess, int max_iterations = 1000);
  double householder(double power, double speed_guess, int max_iterations = 20);

  // friend allows aceesing private/protected members
  friend std::ostream& operator<<(std::ostream& os, const Rider& r);
};

#endif
```

include/screen.h
```
// screen.h
#ifndef SCREEN_H
#define SCREEN_H

#include "SDL3/SDL_events.h"
#include "widget.h"
#include <memory>

class AppState;
class TTF_Font;
class PlotRenderer;
class SimulationRenderer;

enum class ScreenType { Menu, Simulation, Result, Plot };

class IScreen {
public:
  virtual ~IScreen() {}
  virtual void update() = 0;
  virtual void render() = 0;

  // virtual void handle_event(SDL_Event* e) = 0;
  virtual bool handle_event(const SDL_Event* e) {
    if (e->type == SDL_EVENT_KEY_DOWN) {
      if (e->key.key == SDLK_RETURN) {
        // start simulation
        // state->switch_screen(ScreenType::Simulation);
        return true;
      }
    }
    return false;
  }
};

class MenuScreen : public IScreen {
public:
  AppState* state;

  MenuScreen(AppState* s) : state(s) {}

  void update() override {}
  void render() override;
};

class ResultsScreen : public IScreen {
public:
  AppState* state;
  ResultsScreen(AppState* s) : state(s) {}

  void update() override {};

  void render() override;
};

class SimulationScreen : public IScreen {
public:
  // DisplayEngine* display = nullptr;
  int WORLD_WIDTH = 20;

  SimulationScreen(AppState* s);
  ~SimulationScreen(); // delete sim_renderer; }

  void update() override;
  void render() override;

  bool handle_event(const SDL_Event* e) override;

  void cycle_rider(int direction);

private:
  AppState* state;
  std::unique_ptr<SimulationRenderer> sim_renderer;

  int selected_rider_uid = 0;

  // Camera interaction state
  bool dragging = false;
  int drag_start_x = 0;
  int drag_start_y = 0;

  RiderPanel* rider_panel = nullptr;
};

class PlotScreen : public IScreen {
public:
  PlotScreen(AppState* s);
  ~PlotScreen();

  void update() override;
  void render() override;
  bool handle_event(const SDL_Event* e) override;

private:
  AppState* state;
  std::unique_ptr<PlotRenderer> renderer;
};

#endif
```

include/screenmanager.h
```
#ifndef SCREEN_MANAGER_H
#define SCREEN_MANAGER_H

#include "screen.h"
#include <memory>
#include <vector>

class AppState;

enum class PendingActionType { None, Push, Pop, Replace };

struct PendingAction {
  PendingActionType type = PendingActionType::None;
  ScreenType screen;
};

class ScreenManager {
public:
  ScreenManager(AppState* state);

  // Core operations
  void push(ScreenType type);
  void pop();                    // removes top screen
  void replace(ScreenType type); // pop then push

  // Game loop hooks
  void handle_event(const SDL_Event* e);
  void update();
  void render();

  // Utilities
  bool empty() const { return stack.empty(); }
  IScreen* top() const { return stack.empty() ? nullptr : stack.back().get(); }

private:
  AppState* app;
  std::vector<std::unique_ptr<IScreen>> stack;

  std::unique_ptr<IScreen> create_screen(ScreenType type);

  PendingAction pending;
};

#endif
```

include/sim.h
```
// sim.h
#ifndef SIM_H
#define SIM_H

#include "course.h"
#include "rider.h"
#include <mutex>

#include <atomic>

class PhysicsEngine {
private:
  const Course* course;
  mutable std::mutex frame_mtx;
  std::vector<Rider*> riders;

public:
  explicit PhysicsEngine(const Course* c);
  void add_rider(Rider* r);
  void update(double dt);

  const Course* get_course() const { return course; }
  double get_course_length() const { return course->total_length; }

  // do these returns need to/should be const?
  const std::vector<Rider*>& get_riders() const;
  Rider* get_rider(int idx) const;
  std::mutex* get_frame_mutex() const;

  ~PhysicsEngine();
};

// forward declare
class SimulationCondition;

// Your main simulation loop (runs in its own thread or fixed-step driver)
class Simulation {
private:
  PhysicsEngine engine;
  // when this is false, we exit and kill the thread
  std::atomic<bool> running{false};
  // this is different because it pauses
  std::atomic<bool> paused{false};

  double time_factor = 1.0;
  double sim_seconds = 0.0;

  double interp_alpha = 0.0;

  const float dt = 0.1; // 100 Hz physics

  void step_fixed(double dt);

public:
  Simulation(const Course* c);

  void start_realtime();

  void run_max_speed(const SimulationCondition& cond);

  void pause();
  void resume();
  bool is_paused() const;
  void stop();

  double get_time_factor() { return time_factor; }
  void set_time_factor(double f) { time_factor = f; }

  double get_dt() { return dt; }
  double get_interp_alpha() { return interp_alpha; }

  const double get_sim_seconds() const;
  const PhysicsEngine* get_engine() const;
  PhysicsEngine* get_engine();

  std::atomic<bool> physics_error{false};
  std::string physics_error_message;
};

class SimulationCondition {
public:
  virtual ~SimulationCondition() = default;
  virtual bool is_met(const Simulation& sim) const = 0;
};

#endif
```

include/simulationrenderer.h
```
#ifndef SIMULATION_RENDERER_H
#define SIMULATION_RENDERER_H

#include "corerenderer.h"
#include "snapshot.h"
#include <memory>
#include <mutex>

class Simulation;
class Camera;
class RiderPanel;

struct FramePairView {
  const FrameSnapshot* prev;
  const FrameSnapshot* curr;
};

// This renderer extends CoreRenderer with:
// - Camera
// - World-to-screen transform
// - Automatic SnapshotMap generation
// - Course + Rider drawing
class SimulationRenderer : public CoreRenderer {
public:
  SimulationRenderer(SDL_Renderer* r, GameResources* resources, Simulation* sim,
                     std::shared_ptr<Camera> camera);

  ~SimulationRenderer() override = default;

  // Main render function: adds simulation info + world drawables.
  void render_frame() override;
  void update();

  RiderPanel* get_rider_panel() const { return rider_panel; }
  void set_rider_panel(RiderPanel* p) { rider_panel = p; }

  // World drawables
  void add_world_drawable(std::unique_ptr<Drawable> d);

  std::shared_ptr<Camera> get_camera() const { return camera; }

  int pick_rider(double screen_x, double screen_y) const;

  // const SnapshotMap& get_snapshot_map() const { return snapshot_front; }
  FramePairView get_frame_pair() const;
  void build_and_swap_snapshots();

  bool handle_event(const SDL_Event* e);

private:
  // sim and camera are owned by AppState !
  Simulation* sim;                // Not owned
  std::shared_ptr<Camera> camera; // Owned here
  std::vector<std::unique_ptr<Drawable>> world_drawables;

  RiderPanel* rider_panel = nullptr;

  // Double buffers
  FrameSnapshot frame_prev; // published previous
  FrameSnapshot frame_curr; // published current
  FrameSnapshot frame_back; // build buffer
  mutable std::mutex snapshot_swap_mtx;

  bool frames_initialized = false;
};

#endif
```

include/snapshot.h
```
#ifndef SNAPSHOT_H
#define SNAPSHOT_H

#include "pch.hpp"
#include "visualmodel.h"
#include <string>
#include <unordered_map>

enum class PowerTerm : int {
  Aerodynamic = 0,
  Rolling,
  Bearings,
  Gravity,
  Inertia,
  Drivetrain,
  COUNT
};

static constexpr const char* POWER_LABELS[] = {"Aero", "Roll",  "Bear",
                                               "Grav", "Inert", "Drive"};

struct RiderSnapshot {
  const size_t uid;
  std::string name;
  double pos;
  double slope;
  Vector2d pos2d;
  double power;
  double effort;
  double max_effort;
  double speed;
  double km_h;
  double heading;
  int team_id;

  BikeType visual_type;

  std::array<double, (int)PowerTerm::COUNT> power_breakdown;
};

using SnapshotMap = std::unordered_map<int, RiderSnapshot>;

struct FrameSnapshot {
  double sim_time = 0.0;    // seconds (sim clock)
  double sim_dt = 0.0;      // seconds per physics step (constant)
  double time_factor = 1.0; // sim_speed / real_speed
  double real_time = 0.0;   // seconds (steady clock / SDL time) when captured

  SnapshotMap riders;
};

struct InterpolatedFrameView {
  double interp_sim_time; // optional, but useful
  double alpha;

  std::unordered_map<int, Vector2d> rider_pos;
  std::unordered_map<size_t, double> rider_slope;
  std::unordered_map<size_t, double> rider_effort;
};

#endif
```

include/texturemanager.h
```
// texturemanager.h
#ifndef TEXTUREMANAGER_H
#define TEXTUREMANAGER_H

#include "SDL3/SDL_log.h"
#include <string>
#include <unordered_map>

struct SDL_Renderer;
struct SDL_Texture;
struct TTF_Font;

class TextureManager {
public:
  // You must give TextureManager a valid SDL_Renderer* at construction time.
  // It keeps that renderer internally so it can turn surfaces → textures.
  TextureManager(SDL_Renderer* renderer_);

  ~TextureManager();

  // Non‐copyable / non‐movable for simplicity
  TextureManager(const TextureManager&) = delete;
  TextureManager& operator=(const TextureManager&) = delete;

  bool load_texture(const char* id, const char* file_path);
  SDL_Texture* get_texture(const char* id) const;

  // (Optional) Query width/height of a loaded texture.
  bool query_texture(const char* id, float& outW, float& outH) const;

private:
  SDL_Renderer* renderer;
  std::unordered_map<std::string, SDL_Texture*> texture_map;
};

class FontManager {
public:
  FontManager() {};

  ~FontManager();

  // Non‐copyable / non‐movable for simplicity
  FontManager(const FontManager&) = delete;
  FontManager& operator=(const FontManager&) = delete;

  bool load_font(const char* id, const char* file_path, int font_size);
  TTF_Font* get_font(const char* id) const;

private:
  std::unordered_map<std::string, TTF_Font*> font_map;
};

class ResourceProvider {
public:
  virtual TextureManager* get_textureManager() = 0;
  virtual FontManager* get_fontManager() = 0;
  virtual ~ResourceProvider() = default;
};

class GameResources : public ResourceProvider {
public:
  GameResources(SDL_Renderer* renderer_)
      : renderer(renderer_), textureManager(renderer_) {
    load_common_resources();
  }

  TextureManager* get_textureManager() override { return &textureManager; }
  FontManager* get_fontManager() override { return &fontManager; }

  void load_common_resources() {
    if (!textureManager.load_texture("player", "resources/collated_grid.png")) {
      SDL_Log("Failed to load 'player' texture");
    }
    if (!textureManager.load_texture("rider", "resources/rider_sheet.png")) {
      SDL_Log("Failed to load 'rider' texture");
    }
    if (!textureManager.load_texture("rider_front",
                                     "resources/rider_sheet_front.png")) {
      SDL_Log("Failed to load 'rider_front' texture");
    }
    if (!textureManager.load_texture("rider_back",
                                     "resources/rider_sheet_back.png")) {
      SDL_Log("Failed to load 'rider_back' texture");
    }
    if (!textureManager.load_texture("wheel_rear",
                                     "resources/wheel_rear.png")) {
      SDL_Log("Failed to load 'wheel_rear' texture");
    }
    if (!textureManager.load_texture("wheel_front",
                                     "resources/wheel_front.png")) {
      SDL_Log("Failed to load 'wheel_front' texture");
    }
    if (!fontManager.load_font("default", "resources/Roboto-Regular.ttf", 16)) {
      SDL_Log("Failed to load 'default' font");
    }
    if (!fontManager.load_font("stopwatch",
                               "resources/DSEG7Classic-Regular.ttf", 32)) {
      SDL_Log("Failed to load 'stopwatch' font");
    }
  }

private:
  SDL_Renderer* renderer;
  TextureManager textureManager;
  FontManager fontManager;
};

#endif
```

include/visualmodel.h
```
#ifndef VISUALMODEL_H
#define VISUALMODEL_H

namespace {
constexpr double ROAD_WHEEL_RADIUS = 0.311;
constexpr double TT_WHEEL_RADIUS = 0.311;
constexpr double ROAD_WHEELBASE = 0.91;
constexpr double TT_WHEELBASE = 0.99;
constexpr double ROAD_WHEEL_RADIUS_PX = 112.5;
} // namespace

struct Vec2 {
  double x;
  double y;
};

enum class BikeType { Road, TT, Climbing };

struct RiderVisualModel {
  // all in WORLD units (meters)
  double wheel_radius;
  double wheelbase;

  // local offsets relative to rear wheel contact point
  Vec2 front_wheel_offset;
  Vec2 rear_wheel_offset;
  Vec2 body_offset;

  // sprite layout
  int body_frame_count;

  Vec2 front_ground_point;

  float wheel_radius_px;
};

// (0, 0) point is rider.pos
// it is the front edge of the tire at the ground level
inline constexpr RiderVisualModel ROAD_BIKE_VISUAL{
    .wheel_radius = ROAD_WHEEL_RADIUS,
    .wheelbase = ROAD_WHEELBASE,
    .front_wheel_offset = {-ROAD_WHEEL_RADIUS, ROAD_WHEEL_RADIUS},
    .rear_wheel_offset = {-ROAD_WHEELBASE - ROAD_WHEEL_RADIUS,
                          ROAD_WHEEL_RADIUS},
    .body_offset = {-ROAD_WHEEL_RADIUS, ROAD_WHEEL_RADIUS},
    // .body_offset = {0, ROAD_WHEEL_RADIUS},
    .body_frame_count = 24,
    // this is determined by pixels on the actual image
    // .front_wheel_axis = {430.0 / 512.0, 407.0 / 512.0}};
    // pos is wheel radius offset more in either direction (should be 112.5)
    .front_ground_point = {(430.0 + ROAD_WHEEL_RADIUS_PX) / 512.0,
                           (407.0 + ROAD_WHEEL_RADIUS_PX) / 512.0},
    .wheel_radius_px = ROAD_WHEEL_RADIUS_PX};

inline constexpr RiderVisualModel TT_BIKE_VISUAL{
    .wheel_radius = ROAD_WHEEL_RADIUS,
    .wheelbase = TT_WHEELBASE,
    .front_wheel_offset = {-ROAD_WHEEL_RADIUS, 2 * ROAD_WHEEL_RADIUS},
    .rear_wheel_offset = {-TT_WHEELBASE - TT_WHEEL_RADIUS, 2 * TT_WHEEL_RADIUS},
    .body_offset = {0.5, 0.9},
    .body_frame_count = 24,
    .front_ground_point = {430.0 / 512.0, 407.0 / 512.0}};

inline constexpr RiderVisualModel CLIMB_BIKE_VISUAL{
    .wheel_radius = ROAD_WHEEL_RADIUS,
    .wheelbase = ROAD_WHEELBASE,
    .front_wheel_offset = {-ROAD_WHEEL_RADIUS, 2 * ROAD_WHEEL_RADIUS},
    .rear_wheel_offset = {-ROAD_WHEELBASE - ROAD_WHEEL_RADIUS,
                          2 * ROAD_WHEEL_RADIUS},
    .body_offset = {0.5, 0.9},
    .body_frame_count = 24,
    .front_ground_point = {430.0 / 512.0, 407.0 / 512.0}};

inline const RiderVisualModel& resolve_visual_model(BikeType type) {
  switch (type) {
  case BikeType::TT:
    return TT_BIKE_VISUAL;
  case BikeType::Climbing:
    return CLIMB_BIKE_VISUAL;
  case BikeType::Road:
  default:
    return ROAD_BIKE_VISUAL;
  }
}

#endif
```

include/widget.h
```
// widget.h
#ifndef WIDGET_H
#define WIDGET_H

#include "display.h"
#include "sim.h"
#include <SDL3/SDL.h>
#include <SDL3_ttf/SDL_ttf.h>

std::string format_number(double value, int precision = 1);

class Widget : public Drawable {
public:
  RenderLayer layer() const override { return RenderLayer::UI; }
  virtual void render(const RenderContext* ctx) override = 0;
  virtual ~Widget() = default;
  bool visible = true;
};

class Stopwatch : public Widget {
private:
  Simulation* sim;
  TTF_Font* font;
  SDL_Color text_color = SDL_Color{80, 255, 40, 255};
  int screen_x, screen_y;
  int width = 0, height = 0; // Texture dimensions
  int bg_width = 0, bg_height = 0;
  int update_interval_ms;
  char text[16];

  SDL_Texture* texture = nullptr;
  SDL_Texture* bg_texture = nullptr;

  int padding = 6;
  int edge_thickness = 3;
  int content_offset = padding + edge_thickness;

  uint32_t last_update_ticks = 0;

  SDL_Texture* render_time(SDL_Renderer* renderer, const char* s, int& out_w,
                           int& out_h);
  SDL_Texture* create_base(SDL_Renderer* renderer);

public:
  Stopwatch(int x, int y, TTF_Font* font_, Simulation* sim_,
            int update_ms = 100)
      : screen_x(x), screen_y(y), font(font_), sim(sim_),
        update_interval_ms(update_ms) {
    last_update_ticks = 0;
  }

  ~Stopwatch() {
    if (texture)
      SDL_DestroyTexture(texture);
    if (bg_texture)
      SDL_DestroyTexture(bg_texture);
  }

  void update_texture(const RenderContext* ctx);
  void render(const RenderContext* ctx) override;
};

class Button : public Widget {
public:
  using Callback = std::function<void()>;

private:
  int x, y, w, h;
  std::string label;
  TTF_Font* font;
  Callback on_click;
  bool hovered = false;
  bool pressed = false;

public:
  Button(int x, int y, int w, int h, std::string label, TTF_Font* font,
         Callback cb);

  void render(const RenderContext* ctx) override;
  bool handle_event(const SDL_Event* e) override;
};

class TimeFactorButton : public Button {
public:
  TimeFactorButton(int x, int y, int w, int h, double val, Simulation* sim,
                   TTF_Font* font)
      : Button(x, y, w, h, format_label(val), font,
               [sim, val]() { sim->set_time_factor(val); }) {}

private:
  static std::string format_label(double v) {
    char buf[16];
    snprintf(buf, sizeof(buf), "%.1f ×", v);
    return std::string(buf);
  }
};

class PauseButton : public Button {
private:
  Simulation* sim = nullptr;

public:
  PauseButton(int x, int y, int w, int h, Simulation* sim, TTF_Font* font);
  void render(const RenderContext* ctx) override;
};

class TimeFactorSlider : public Widget {
private:
  int x, y, w, h;
  double neutral_point = 0.3; // where factor = 1.0
  int marker_width = 4;
  bool dragging = false;
  double slider_pos = 0.5; // slider position 0..1
  Simulation* sim;

public:
  TimeFactorSlider(int x_, int y_, int w_, int h_, Simulation* sim_)
      : x(x_), y(y_), w(w_), h(h_), sim(sim_) {}

  void render(const RenderContext* ctx) override;
  bool handle_event(const SDL_Event* e) override;

private:
  double slider_to_factor(double t);
  double factor_to_slider(double f);
};

class ValueField : public Widget {
protected:
  int x, y, w, h;
  TTF_Font* font;
  SDL_Color text_color = {255, 255, 255, 255};

  // Caching
  std::string current_text;
  SDL_Texture* texture = nullptr;
  SDL_Texture* bg_texture = nullptr;

  void create_bg(SDL_Renderer* renderer);
  void update_texture(SDL_Renderer* renderer);
  // so child class can overwrite with custom logic
  virtual std::string get_display_text() const { return current_text; }

public:
  ValueField(int x, int y, int w, int h, TTF_Font* font);
  virtual ~ValueField();

  void set_text(const std::string& text);
  const std::string& get_text() const { return current_text; }

  void set_position(int new_x, int new_y) {
    x = new_x;
    y = new_y;
  }
  int get_width() const { return w; }

  // Standard Widget interface
  void render(const RenderContext* ctx) override;
  bool handle_event(const SDL_Event* e) override { return false; }
};

class RiderValueField : public ValueField {
public:
  using DataGetter = std::function<std::string(const RiderSnapshot&)>;

private:
  size_t target_rider_id;
  DataGetter getter;

public:
  RiderValueField(int x, int y, int w, int h, TTF_Font* font, size_t rider_id,
                  DataGetter getter);

  void render_with_snapshot(const RenderContext* ctx,
                            const RiderSnapshot* snap);
};

class TimeControlPanel : public Widget {
private:
  int x, y, h;
  int valfield_w = 50;
  int slider_w = 120;
  int button_w = 50;
  int gap_w = 5;
  int next_x = x + gap_w;
  std::vector<std::unique_ptr<Widget>> children;

  ValueField* time_factor_field = nullptr;

  // for reading current time_factor
  Simulation* sim = nullptr;

public:
  TimeControlPanel(int x_, int y_, int h_, TTF_Font* font, Simulation* sim);

  void render(const RenderContext* ctx) override;
  bool handle_event(const SDL_Event* e) override;
};

class MetricRow {
private:
  std::string label_txt;
  std::string unit_txt;
  TTF_Font* font;

  // Components
  std::unique_ptr<RiderValueField> field;
  SDL_Texture* label_tex = nullptr;
  SDL_Texture* unit_tex = nullptr;

  int x, y;
  int label_width = 80; // Fixed width so boxes align vertically
  int padding = 10;

public:
  MetricRow(int x, int y, TTF_Font* font, size_t id, std::string label,
            std::string unit, RiderValueField::DataGetter getter);

  ~MetricRow();

  // void render(const RenderContext* ctx) override;
  void render_for_rider(const RenderContext* ctx, const RiderSnapshot* snap);

  // Helper to calculate total height for the panel
  int get_height() const { return 30; } // simplified
  void set_position(int new_x, int new_y);
};

class RiderPanel : public Widget {
private:
  int x, y;
  int rider_uid = 0;
  TTF_Font* font;

  std::string title;
  SDL_Texture* title_tex = nullptr;

  bool show_plot = false;

  // All the rows
  std::vector<std::unique_ptr<MetricRow>> rows;

public:
  RiderPanel(int x, int y, TTF_Font* font);
  ~RiderPanel();

  void set_rider_id(int uid);
  // Usage: panel->add_row("Speed", "km/h", [](auto s){ return ... });
  void add_row(std::string label, std::string unit,
               RiderValueField::DataGetter getter);

  void render(const RenderContext* ctx) override;
  void render_imgui(const RenderContext* ctx) override;

  void render_plot_overlay(const RenderContext* ctx);
};

class BaseEditableField : public ValueField {
public:
  using CommitCallback = std::function<void(const std::string&)>;

protected:
  bool editing = false;
  std::string buffer;

  SDL_Window* window;
  CommitCallback on_commit;

  // blinking cursor
  Uint32 last_cursor_blink = 0;
  bool cursor_visible = true;
  const Uint32 BLINK_MS = 500;

  // hook: validation/acceptance of character input
  virtual bool accept_char(char c, const std::string& before) = 0;

  // helper: commit and fire callback
  void commit();

  // Chooses which text ValueField should render
  std::string current_display_text() const;

public:
  BaseEditableField(int x, int y, int w, int h, TTF_Font* font, SDL_Window* win,
                    CommitCallback cb)
      : ValueField(x, y, w, h, font), window(win), on_commit(std::move(cb)) {}

  bool handle_event(const SDL_Event* e) override;
  void render(const RenderContext* ctx) override;
};

class EditableNumberField : public BaseEditableField {
public:
  EditableNumberField(int x, int y, int w, int h, TTF_Font* font,
                      SDL_Window* win, std::function<void(double)> cb)
      : BaseEditableField(x, y, w, h, font, win,
                          [cb](const std::string& s) { cb(atof(s.c_str())); }) {
  }

protected:
  bool accept_char(char c, const std::string& before) override;
};

class EditableStringField : public BaseEditableField {
public:
  EditableStringField(int x, int y, int w, int h, TTF_Font* font,
                      SDL_Window* win,
                      std::function<void(const std::string&)> cb)
      : BaseEditableField(x, y, w, h, font, win, std::move(cb)) {}

protected:
  bool accept_char(char c, const std::string&) override { return true; }
};

#endif
```

src/appstate.cpp
```
// src/appstate.cpp
#include "appstate.h"
#include "SDL3/SDL_render.h"
#include "SDL3_ttf/SDL_ttf.h"
#include "backends/imgui_impl_sdl3.h"
#include "backends/imgui_impl_sdlrenderer3.h"
#include "implot.h"
#include "screen.h"
#include "screenmanager.h"

AppState::AppState() {
  // 1. Initialize SDL Core
  if (!SDL_Init(SDL_INIT_VIDEO)) {
    SDL_Log("Couldn't initialize SDL: %s", SDL_GetError());
    throw std::runtime_error("SDL Init Failed");
  }
  if (!TTF_Init()) {
    SDL_Log("Couldn't initialize TTF: %s", SDL_GetError());
    throw std::runtime_error("TTF Init Failed");
  }

  // 2. Create Window and Renderer ONCE
  if (!SDL_CreateWindowAndRenderer("Cycle Sim", SCREEN_WIDTH, SCREEN_HEIGHT, 0,
                                   &window, &renderer)) {
    SDL_Log("CreateWindowAndRenderer failed: %s", SDL_GetError());
    throw std::runtime_error("Window Creation Failed");
  }

  // init imgui
  // 1) Create ImGui context
  IMGUI_CHECKVERSION();
  ImGui::CreateContext();
  ImPlot::CreateContext(); // Don't forget ImPlot's context too
  ImGui::StyleColorsDark();
  ImGui_ImplSDL3_InitForSDLRenderer(window, renderer);
  ImGui_ImplSDLRenderer3_Init(renderer);

  // 3. Initialize Shared Resources
  resources = new GameResources(renderer);

  // 4. Initialize Simulation
  // v
  course = new Course(Course::create_endulating());
  sim = new Simulation(course); // Sim now owns the course
  sim->set_time_factor(0.1);

  screens = new ScreenManager(this);
  screens->push(ScreenType::Simulation);

  // (Optional) Setup default riders here or in Main
}

AppState::~AppState() {
  // Cleanup in reverse order of creation
  if (physics_thread) {
    sim->stop();
    physics_thread->join();
    delete physics_thread;
  }

  if (sim)
    delete sim;
  if (course)
    delete course;
  if (resources)
    delete resources;
  if (screens)
    delete screens;

  if (renderer)
    SDL_DestroyRenderer(renderer);
  if (window)
    SDL_DestroyWindow(window);

  TTF_Quit();
  SDL_Quit();
}

bool AppState::load_image(const char* id, const char* filename) {
  return resources->get_textureManager()->load_texture(id, filename);
}
```

src/camera.cpp
```
#include "camera.h"
#include "pch.hpp"

Camera::Camera(const Course* course_, int world_width_, Vector2d screensize_)
    : course(course_), world_width(world_width_), screensize(screensize_),
      scale(screensize_.x() / (double)world_width_), vert_scale(1.0),
      pos(0.0, 0.0) {
  target_uid = 0;
}

// ------------------------
// FOLLOWING LOGIC
// ------------------------
void Camera::set_target_id(int rider_uid) { target_uid = rider_uid; }

void Camera::clear_target() { target_uid.reset(); }

void Camera::update(const InterpolatedFrameView& view) {
  if (!target_uid)
    return;
  int id = *target_uid;

  auto it = view.rider_pos.find(id);
  if (it == view.rider_pos.end())
    return;

  Vector2d target_pos = it->second;
  // Smooth interpolation toward target
  pos = pos + follow_strength * (target_pos - pos);
  pos = target_pos;
}

// ------------------------
// MANUAL CAMERA CONTROLS
// ------------------------
void Camera::pan(double dx, double dy) {
  // User panning breaks following
  clear_target();

  // convert screen dx to world dx
  Vector2d delta(dx / scale, dy / (-vert_scale));

  pos += delta;
}

void Camera::zoom(double amount) {
  // Simple zoom factor
  double factor = 1.0 + amount;

  scale *= factor;
  if (scale < 0.01)
    scale = 0.01;
  if (scale > 100.0)
    scale = 100.0;
}

// ------------------------
// TRANSFORMS
// ------------------------
Vector2d Camera::world_to_screen(Vector2d world) const {
  return ((world - pos) * scale).cwiseProduct(Vector2d(1.0, -vert_scale)) +
         screensize * 0.5;
}

MatrixX2d Camera::world_to_screen(MatrixX2d w) const {
  MatrixX2d r = w;

  r.rowwise() -= pos;
  r *= scale;
  r.col(1) *= -vert_scale;
  r.rowwise() += screensize * 0.5;

  return r;
}

Vector2d Camera::screen_to_world(Vector2d s) const {
  Vector2d centered = s - screensize * 0.5;

  Vector2d scaled;
  scaled.x() = centered.x() / scale;
  scaled.y() = centered.y() / (-vert_scale);

  return scaled + pos;
}
```

src/corerenderer.cpp
```
#include "corerenderer.h"
#include "display.h"
#include <memory>

CoreRenderer::CoreRenderer(SDL_Renderer* r, GameResources* res)
    : renderer(r), resources(res) {}

void CoreRenderer::add_drawable(std::unique_ptr<Drawable> d) {
  drawables.push_back(std::move(d));
}

void CoreRenderer::clear_drawables() { drawables.clear(); }

void CoreRenderer::render_frame() {
  // No camera, no simulation, no snapshot logic.
  // Only UI drawables.

  SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
  SDL_RenderClear(renderer);

  // RenderContext ctx;
  // ctx.renderer = renderer;
  // ctx.resources = resources;
  // ctx.camera_weak = std::weak_ptr<Camera>();
  // ctx.rider_snapshots = nullptr; // Not used
  //
  RenderContext ctx;
  ctx.renderer = renderer;
  ctx.resources = resources;

  for (auto& d : drawables) {
    d->render(&ctx);
  }

  SDL_RenderPresent(renderer);
}
```

src/course.cpp
```
#include "course.h"
#include "SDL3/SDL_log.h"
#include "pch.hpp"
#include <stdexcept>

// make CourseSegment easier to print
std::ostream& operator<<(std::ostream& os, const Segment& cs) {
  os << cs.length << " m at " << cs.slope * 100 << "%";
  return os;
}

Course::Course(const std::vector<std::array<double, 3>> segments_) {
  double x = 0.0, y = 0.0;
  visual_points.push_back(Vector2d(x, y));

  for (auto [len, slope, heading] : segments_) {
    segments.push_back({x, len, slope, x + len, heading});
    altitudes.push_back(y);

    x += len;
    y += len * slope;
    visual_points.push_back(Vector2d(x, y));
  }
  total_length = x;
  SDL_Log("%f", total_length);
}

Course
Course::from_segments(const std::vector<std::array<double, 3>> segments) {
  return Course(segments);
}

Course Course::create_flat() {
  std::vector<std::array<double, 3>> v = {{300000, 0, 0}};
  return Course(v);
}

Course Course::create_endulating() {
  std::vector<std::array<double, 3>> v = {
      {10, 0, 0}, {200, 0.1, 0}, {200, 0, 0}, {500, 0.05, 0}};
  return Course(v);
}

double Course::get_altitude(double pos) const {
  int idx = find_segment(pos);
  return altitudes[idx] + segments[idx].altitude_at(pos);
}

double Course::get_slope(double pos) const {
  return segments[find_segment(pos)].slope;
}

Wind Course::get_wind(double pos) const { return Wind{0, 1}; }

MatrixX2d Course::get_points(double x_min, double x_max) const {
  if (x_min > x_max)
    std::swap(x_min, x_max);
  if (x_min < 0)
    x_min = 0;
  int i0 = find_segment(x_min);
  int i1 = find_segment(x_max);

  // count points: endpoints + internal breaks
  int count = 2; // for x_min and x_max
  for (int i = i0 + 1; i <= i1; ++i) {
    double bx = segments[i].start_x;
    if (bx > x_min && bx < x_max)
      ++count;
  }

  MatrixX2d pts(count, 2);
  int row = 0;
  // x_min
  pts(row, 0) = x_min;
  pts(row, 1) = get_altitude(x_min);
  ++row;

  // internal breaks
  for (int i = i0 + 1; i <= i1; ++i) {
    double bx = segments[i].start_x;
    if (bx > x_min && bx < x_max) {
      pts(row, 0) = bx;
      pts(row, 1) = altitudes[i];
      ++row;
    }
  }

  // x_max
  pts(row, 0) = x_max;
  pts(row, 1) = get_altitude(x_max);
  return pts;
}

int Course::find_segment(double x) const {
  if (x > total_length) {
    SDL_Log("Trying to find segment for x > total_length (%.1f > %f.1f) in "
            "Course::find segment()",
            x, total_length);
    return segments.size() - 1;
  }
  int lo = 0, hi = segments.size() - 1;
  while (lo <= hi) {
    int mid = (lo + hi) / 2;
    if (x < segments[mid].start_x)
      hi = mid - 1;
    else if (x >= segments[mid].end_x)
      lo = mid + 1;
    else
      return mid;
  }
  throw std::out_of_range("x out of course bounds");
}

void Course::print() {
  std::cout << "Course:" << std::endl;
  for (const Segment& course_segment : segments) {
    std::cout << course_segment << std::endl;
  }
  for (int i = 0; i < segments.size(); i++) {
    std::cout << segments[i].start_x << ", " << altitudes[i] << std::endl;
  }
  // for (const std::array<double, 3> &seg_range : segment_ranges) {
  //   std::cout << "x_start: " << seg_range[0] << ",\tx_end:" << seg_range[1]
  //             << ",\tslope: " << seg_range[2] * 100 << "%" << std::endl;
  // }
}
```

src/display.cpp
```
#include "display.h"
#include "SDL3/SDL_log.h"
#include "SDL3/SDL_rect.h"
#include "SDL3/SDL_render.h"
#include "pch.hpp"
#include "texturemanager.h"
#include "visualmodel.h"
#include <SDL3/SDL.h>
#include <SDL3_ttf/SDL_ttf.h>
#include <vector>

double effort_to_freq(double effort, double max_effort) {
  double anim_rpm;
  double min_rpm = 40.0;
  double max_rpm = 130.0;

  if (effort <= 1.0) {
    // 0 → 1  maps to 40 → 100
    anim_rpm = min_rpm + effort * (100.0 - min_rpm);
  } else {
    // 1 → max_effort maps to 100 → 130
    double t = (effort - 1.0) / (max_effort - 1.0);
    anim_rpm = 100.0 + t * (max_rpm - 100.0);
  }
  return anim_rpm / 60;
}

CourseDrawable::CourseDrawable(const Course* course_) : course(course_) {}

void CourseDrawable::render(const RenderContext* ctx) {
  const std::vector<Vector2d>& world_pts = course->visual_points;

  if (world_pts.empty())
    return;

  std::vector<SDL_FPoint> screen_points;
  screen_points.reserve(world_pts.size());

  // this loop can be optimized but apparently for <10k points, its instant
  auto camera = ctx->camera_weak.lock();
  if (!camera) {
    SDL_Log("failed to lock camera weak_ptr");
    return;
  }
  for (const auto& wp : world_pts) {
    if (abs(wp.x() - camera->get_pos().x()) > 2000)
      continue;

    Vector2d sp = camera->world_to_screen(wp);
    screen_points.push_back(SDL_FPoint{(float)sp.x(), (float)sp.y()});
  }

  SDL_SetRenderDrawColor(ctx->renderer, 200, 200, 200, 255);
  // SDL_RenderLines(ctx->renderer, points, pts.rows());
  // delete[] points;
  SDL_RenderLines(ctx->renderer, screen_points.data(), screen_points.size());
};

// maybe move into helpers or sth?
Vector2d rotate(Vec2 p, double a) {
  return {float(p.x * cos(a) - p.y * sin(a)),
          float(p.x * sin(a) + p.y * cos(a))};
}

void RiderDrawable::render(const RenderContext* ctx) {
  if (ctx->curr_frame->riders.empty() || ctx->prev_frame->riders.empty())
    return;

  auto cam = ctx->camera_weak.lock();
  if (!cam)
    return;

  const auto& prev = ctx->prev_frame->riders;
  const auto& curr = ctx->curr_frame->riders;

  // for (const auto& [id, snap] : *ctx->rider_snapshots) {
  for (auto& [id, s1] : curr) {
    // auto it0 = prev.find(id);
    // if (it0 == prev.end())
    //   continue; // new rider appeared
    // const RiderSnapshot& s0 = it0->second;

    Vector2d pos2d = ctx->view.rider_pos.at(id);
    double slope = ctx->view.rider_slope.at(id);
    double effort = ctx->view.rider_effort.at(id);

    // ---------------------------
    // Resolve visual model
    // ---------------------------
    const RiderVisualModel& model = resolve_visual_model(s1.visual_type);

    auto [it, inserted] = visuals.try_emplace(id);
    RiderVisualState& vis = it->second;

    if (inserted) {
      vis.last_anim_sim_time = ctx->view.interp_sim_time;
      vis.anim_phase = 0.0;
      vis.wheel_angle = 0.0;
    }

    // ---------------------------
    // Camera & orientation
    // ---------------------------
    Vector2d front_ground_world = pos2d;
    Vector2d front_ground_screen = cam->world_to_screen(front_ground_world);

    double tilt_rad = std::atan(slope);
    double tilt_deg = tilt_rad * 180.0 / M_PI;

    // ---------------------------
    // Rotate offsets in world space
    // ---------------------------
    Vector2d front_wheel_world =
        front_ground_world + rotate(model.front_wheel_offset, tilt_rad);

    Vector2d rear_wheel_world =
        front_ground_world + rotate(model.rear_wheel_offset, tilt_rad);

    Vector2d body_world =
        front_ground_world + rotate(model.body_offset, tilt_rad);

    // ---------------------------
    // World → screen
    // ---------------------------
    Vector2d front_wheel_screen = cam->world_to_screen(front_wheel_world);

    Vector2d rear_wheel_screen = cam->world_to_screen(rear_wheel_world);

    Vector2d body_screen = cam->world_to_screen(body_world);

    // ---------------------------
    // Distance-based wheel rotation
    // ---------------------------
    if (std::isnan(vis.last_pos))
      vis.last_pos = pos2d.x();

    double ds = pos2d.x() - vis.last_pos;
    vis.last_pos = pos2d.x();

    vis.wheel_angle += ds / model.wheel_radius;

    // ---------------------------
    // Draw wheels
    // ---------------------------
    SDL_Texture* front_wheel_tex =
        ctx->resources->get_textureManager()->get_texture("wheel_front");
    SDL_Texture* rear_wheel_tex =
        ctx->resources->get_textureManager()->get_texture("wheel_rear");

    float wheel_screen_diameter = cam->get_scale() * 2.0 * model.wheel_radius;

    SDL_FRect front_wheel_dst{
        float(front_wheel_screen.x() - wheel_screen_diameter * 0.5),
        float(front_wheel_screen.y() - wheel_screen_diameter * 0.5),
        wheel_screen_diameter, wheel_screen_diameter};

    SDL_FRect rear_wheel_dst{
        float(rear_wheel_screen.x() - wheel_screen_diameter * 0.5),
        float(rear_wheel_screen.y() - wheel_screen_diameter * 0.5),
        wheel_screen_diameter, wheel_screen_diameter};

    SDL_FPoint wheel_center{wheel_screen_diameter * 0.5f,
                            wheel_screen_diameter * 0.5f};

    double wheel_angle_deg = vis.wheel_angle * 180.0 / M_PI + tilt_deg;

    // ---------------------------
    // Draw rider / bike texture
    // ---------------------------
    SDL_Texture* rider_front_tex =
        ctx->resources->get_textureManager()->get_texture("rider_front");
    SDL_Texture* rider_back_tex =
        ctx->resources->get_textureManager()->get_texture("rider_back");

    // float rider_screen_size =
    //     cam->get_scale() * model.wheelbase * 512.0f / 330.0f;

    float wheel_radius_px = 112.5;

    float scale_from_radius =
        cam->get_scale() * model.wheel_radius / model.wheel_radius_px;

    float rider_screen_size = scale_from_radius * 512.0f;

    // texture-space anchor → screen pixels
    float anchor_x = model.front_ground_point.x * rider_screen_size;
    float anchor_y = model.front_ground_point.y * rider_screen_size;

    SDL_FRect rider_dst{float(front_ground_screen.x() - anchor_x),
                        float(front_ground_screen.y() - anchor_y),
                        rider_screen_size, rider_screen_size};

    SDL_FPoint rider_pivot{anchor_x, anchor_y};

    double prev_sim_time = ctx->prev_frame->sim_time;
    double curr_sim_time = ctx->curr_frame->sim_time;

    if (std::isnan(vis.last_anim_sim_time))
      vis.last_anim_sim_time = ctx->view.interp_sim_time;

    double dt = ctx->view.interp_sim_time - vis.last_anim_sim_time;

    if (dt > 0.0) {
      double hz = effort_to_freq(effort, s1.max_effort);
      vis.anim_phase = std::fmod(vis.anim_phase + hz * dt, 1.0);
      vis.last_anim_sim_time = ctx->view.interp_sim_time;
    }

    constexpr int COLS = 6;
    constexpr int ROWS = 4;
    constexpr int TOTAL_FRAMES = COLS * ROWS;

    int idx = static_cast<int>(vis.anim_phase * TOTAL_FRAMES);
    idx = std::clamp(idx, 0, TOTAL_FRAMES - 1);

    int row = idx / COLS;
    int col = idx % COLS;

    SDL_FRect src{static_cast<float>(col * 512), static_cast<float>(row * 512),
                  512, 512};

    // draw the back side first, because wheels appear on top of it
    SDL_RenderTextureRotated(ctx->renderer, rider_back_tex, &src, &rider_dst,
                             -tilt_deg, &rider_pivot, SDL_FLIP_NONE);

    SDL_RenderTextureRotated(ctx->renderer, rear_wheel_tex, nullptr,
                             &rear_wheel_dst, wheel_angle_deg, &wheel_center,
                             SDL_FLIP_NONE);

    SDL_RenderTextureRotated(ctx->renderer, front_wheel_tex, nullptr,
                             &front_wheel_dst, wheel_angle_deg, &wheel_center,
                             SDL_FLIP_NONE);

    SDL_RenderTextureRotated(ctx->renderer, rider_front_tex, &src, &rider_dst,
                             -tilt_deg, &rider_pivot, SDL_FLIP_NONE);

    // show the anchor point
    SDL_SetRenderDrawColor(ctx->renderer, 255, 0, 0, 255);
    SDL_FRect anchor_rect = SDL_FRect{(float)front_ground_screen.x() - 2,
                                      (float)front_ground_screen.y() - 2, 5, 5};
    SDL_RenderRect(ctx->renderer, &anchor_rect);
  }
}
```

src/haha.cpp
```
int main() { return 0; }
```

src/helpers.cpp
```
#include <SDL3/SDL.h>
#include <iostream>

void convert_color(SDL_Surface* surf) {
    SDL_LockSurface(surf);

    int w = surf->w;
    int h = surf->h;
    int pitch = surf->pitch;
    auto details = SDL_GetPixelFormatDetails(surf->format);
    int bpp = details->bytes_per_pixel;

    for (int y = 0; y < h; y++) {
        Uint8* row = (Uint8*)surf->pixels + y * pitch;
        for (int x = 0; x < w; x++) {
            Uint8* pixelPtr = row + x * bpp;
            Uint32 rawpixel = 0;

            // 1) Read exactly bpp bytes into a Uint32:
            switch (bpp) {
            case 1:
                rawpixel = *pixelPtr;
                break;
            case 2:
                rawpixel = *(Uint16*)pixelPtr;
                break;
            case 3:
                if (SDL_BYTEORDER == SDL_BIG_ENDIAN) {
                    rawpixel = (pixelPtr[0] << 16) | (pixelPtr[1] << 8) | pixelPtr[2];
                } else {
                    rawpixel = pixelPtr[0] | (pixelPtr[1] << 8) | (pixelPtr[2] << 16);
                }
                break;
            case 4:
                rawpixel = *(Uint32*)pixelPtr;
                break;
            }

            // 2) Extract R,G,B,A:
            Uint8 r, g, b, a;
            SDL_GetRGBA(rawpixel, details, nullptr, &r, &g, &b, &a);

            // 3) Decide if we want to repaint it:
            if (r > 120 && g < 20 && b > 120) {
                Uint8 newR = 255;
                Uint8 newG = 0;
                Uint8 newB = 255;
                // keep same alpha
                Uint32 new_pixel = SDL_MapRGBA(details, nullptr, newR, newG, newB, a);

                // 4) Write exactly bpp bytes back:
                switch (bpp) {
                case 1:
                    *pixelPtr = (Uint8)(new_pixel & 0xFF);
                    break;
                case 2:
                    *(Uint16*)pixelPtr = (Uint16)(new_pixel & 0xFFFF);
                    break;
                case 3:
                    if (SDL_BYTEORDER == SDL_BIG_ENDIAN) {
                        pixelPtr[0] = (new_pixel >> 16) & 0xFF;
                        pixelPtr[1] = (new_pixel >> 8) & 0xFF;
                        pixelPtr[2] = (new_pixel >> 0) & 0xFF;
                    } else {
                        pixelPtr[0] = (new_pixel >> 0) & 0xFF;
                        pixelPtr[1] = (new_pixel >> 8) & 0xFF;
                        pixelPtr[2] = (new_pixel >> 16) & 0xFF;
                    }
                    break;
                case 4:
                    *(Uint32*)pixelPtr = new_pixel;
                    break;
                }
            }
        }
    }

    SDL_UnlockSurface(surf);
}

SDL_Surface* load_transparent_bmp(const char* filename) {
    // The final texture
    SDL_Texture* newTexture = NULL;

    // Load image at specified path
    SDL_Surface* surf = SDL_LoadBMP(filename);

    convert_color(surf);
    // Color key image
    const SDL_PixelFormatDetails* fmt_details = SDL_GetPixelFormatDetails(surf->format);
    SDL_SetSurfaceColorKey(surf, true, SDL_MapRGB(fmt_details, nullptr, 0xFF, 0, 0xFF));

    return surf;
}

const SDL_Texture* load_from_file(SDL_Renderer* renderer, const char* filename) {
    SDL_Surface* surf = load_transparent_bmp(filename);
    if (!surf) {
        std::cerr << "IMG_Load Error: " << SDL_GetError() << "\n";
        return NULL;
    }
    // 2) Create texture
    SDL_Texture* tex = SDL_CreateTextureFromSurface(renderer, surf);
    if (!tex) {
        std::cerr << "SDL_CreateTextureFromSurface Error: " << SDL_GetError() << "\n";
        SDL_DestroySurface(surf);
        return NULL;
    }

    // 3) Save dimensions
    // int width = surf->w;
    // int height = surf->h;

    SDL_DestroySurface(surf);
    return tex;
}
```

src/main.cpp
```
#include "SDL3/SDL_events.h"
#include "SDL3/SDL_init.h"
#include "appstate.h"
#include "backends/imgui_impl_sdl3.h"
#include "screenmanager.h"
#include "sim.h"
#include <chrono>
#include <exception>
#define SDL_MAIN_USE_CALLBACKS 1 /* use the callbacks instead of main() */
#include "screen.h"
#include <SDL3/SDL.h>
#include <SDL3/SDL_main.h>

int SCREEN_WIDTH = 1000;
int SCREEN_HEIGHT = 640;
int WORLD_WIDTH = 400;

SDL_AppResult SDL_AppInit(void** appstate, int argc, char* argv[]) {
  try {
    auto* state = new AppState();

    Team team("Team1");
    Rider* r = Rider::create_generic(team);
    state->sim->get_engine()->add_rider(r);

    Rider* r2 = new Rider("Pedro", 320, 90, 0.3, Bike::create_generic(), team);
    r2->pos = 2;
    state->sim->get_engine()->add_rider(r2);

    Rider* r3 = new Rider("Marjo", 300, 88, 0.3, Bike::create_generic(), team);
    r2->pos = 1.5;
    state->sim->get_engine()->add_rider(r3);

    state->physics_thread =
        new std::thread([sim = state->sim]() { sim->start_realtime(); });

    // state->window =
    //     SDL_CreateWindow("Cycling Sim", SCREEN_WIDTH, SCREEN_HEIGHT, 0);
    // state->renderer = SDL_CreateRenderer(state->window, nullptr);

    state->screens->replace(ScreenType::Simulation);

    *appstate = state;
    return SDL_APP_CONTINUE;
  } catch (const std::exception& e) {
    SDL_Log("Application init failed: %s", e.what());
    return SDL_APP_FAILURE;
  }
}

/* This function runs when a new event (mouse input, keypresses, etc) occurs. */
SDL_AppResult SDL_AppEvent(void* appstate, SDL_Event* event) {
  ImGui_ImplSDL3_ProcessEvent(event);
  auto* state = static_cast<AppState*>(appstate);
  if (event->type == SDL_EVENT_QUIT) {
    return SDL_APP_SUCCESS; /* end the program, reporting success */
  }

  if (event->type == SDL_EVENT_KEY_DOWN) {
    switch (event->key.key) {
    case SDLK_ESCAPE:
      state->screens->replace(ScreenType::Menu);
      return SDL_APP_CONTINUE;

    case SDLK_P:
      state->screens->replace(ScreenType::Plot); // new plot screen
      return SDL_APP_CONTINUE;

    case SDLK_S:
      state->screens->replace(ScreenType::Simulation);
      return SDL_APP_CONTINUE;
    }
  }

  // Pass event to current screen
  state->screens->handle_event(event);

  return SDL_APP_CONTINUE; /* carry on with the program! */
}

/* This function runs once per frame, and is the heart of the program. */
SDL_AppResult SDL_AppIterate(void* appstate) {
  auto* state = static_cast<AppState*>(appstate);

  auto now = std::chrono::steady_clock::now();
  std::chrono::duration<double> dt = now - state->last_frame_time;

  if (dt.count() >= 1.0 / state->FPS) {
    state->screens->update();
    state->screens->render();
    state->last_frame_time = now;
  } else {
    double remaining = (1.0 / state->FPS) - dt.count();
    std::this_thread::sleep_for(std::chrono::duration<double>(remaining));
  }

  if (state->sim->physics_error) {
    SDL_Log("Physics thread exception: %s",
            state->sim->physics_error_message.c_str());

    state->sim->stop();
    // switch to error screen, pause sim, etc.
  }

  return SDL_APP_CONTINUE; /* carry on with the program! */
}

/* This function runs once at shutdown. */
void SDL_AppQuit(void* appstate, SDL_AppResult result) {
  auto* state = static_cast<AppState*>(appstate);

  delete state;
}
```

src/plotrenderer.cpp
```
#include "plotrenderer.h"
#include "backends/imgui_impl_sdlrenderer3.h"
#include "display.h"
#include "implot.h"
#include <cmath>

PlotRenderer::PlotRenderer(SDL_Renderer* r, GameResources* res)
    : CoreRenderer(r, res) {}

void PlotRenderer::render_frame() {
  // Clear screen first
  SDL_SetRenderDrawColor(renderer, 20, 20, 20, 255);
  SDL_RenderClear(renderer);

  // --- Render standard CoreRenderer widgets ---
  RenderContext ctx;
  ctx.renderer = renderer;
  ctx.resources = resources;
  ctx.camera_weak = std::weak_ptr<Camera>();
  // ctx.rider_snapshots = nullptr;

  for (auto& d : drawables)
    d->render(&ctx);

  // --- ImGui pass ---
  ImGui::NewFrame();
  render_plot_imgui();
  ImGui::Render();
  ImGui_ImplSDLRenderer3_RenderDrawData(ImGui::GetDrawData(), renderer);

  SDL_RenderPresent(renderer);
}

void PlotRenderer::render_plot_imgui() {
  ImGui::Begin("Plot");

  static float xs[100], ys[100];
  static bool init = false;

  if (!init) {
    for (int i = 0; i < 100; ++i) {
      xs[i] = i * 0.1f;
      ys[i] = sinf(xs[i]);
    }
    init = true;
  }

  if (ImPlot::BeginPlot("Example Plot")) {
    ImPlot::PlotLine("sin(x)", xs, ys, 100);
    ImPlot::EndPlot();
  }

  ImGui::End();
}

bool PlotRenderer::handle_event(const SDL_Event* e) {
  // UI above world
  for (auto& d : drawables)
    if (d->handle_event(e))
      return true;

  return false;
}
```

src/rider.cpp
```
#include "rider.h"
#include "course.h"
#include <cmath>
#include <exception>
#include <iostream>
// for std::setprecision
#include <iomanip>
#include <numeric>

#include "helpers.h"
#include "snapshot.h"

size_t Rider::global_id_counter = 0;

const double ETOL = 1e-1; // W
const double ERTOL = 1e-3;
const double PTOL = 2e-3; // m/s
const double PRTOL = 1e-4;

const double RHO = 1.2234;
const double G = 9.80665;

const double PI = 3.14159265358979323846;

bool is_close(double value, double target, double tol, double rtol) {
  return std::fabs(value - target) <= tol + rtol * std::fabs(target);
}

Bike::Bike(double mass_, double wheel_i_, double wheel_r_,
           double wheel_drag_factor_, double crr_, double dt_loss_,
           BikeType type_)
    : mass(mass_), wheel_i(wheel_i_), wheel_r(wheel_r_),
      wheel_drag_factor(wheel_drag_factor_), crr(crr_), dt_loss(dt_loss_),
      type(type_) {}

Bike Bike::create_generic() {
  return Bike(7.0, 0.14, 0.311, 0, 0.006, 0.02, BikeType::Road);
}

Team::Team(const char* name_) : name(name_) { id = 0; }

Rider::Rider(std::string name_, double ftp_base_, double mass_, double cda_,
             Bike bike_, Team team_)
    : uid(global_id_counter++), name(name_), ftp_base(ftp_base_), mass(mass_),
      cda(cda_), bike(bike_), team(team_) {
  cda_factor = 1.0;
  target_effort = 0.8;
  pos = 0;
  speed = 0;
  slope = 0;

  heading = PI / 3;

  set_cda_factor(1);
  change_bike(bike);

  timestep = 1;
}

Rider* Rider::create_generic(Team team_) {
  Bike bike = Bike::create_generic();
  return new Rider("Joe Moe", 250, 65, 0.3, bike, team_);
}

void Rider::set_course(const ICourseView* cv) { course = cv; }

std::ostream& operator<<(std::ostream& os, const Rider& r) {
  os << std::fixed << std::setprecision(1) << r.name << ":\t" << r.ftp_base
     << " W\t" << r.mass << " kg\npos: " << r.pos
     << "m\tspeed: " << r.speed * 3.6 << " km/h" << std::endl;
  return os;
}

Vector2d Rider::get_pos2d() const { return _pos2d; }

void Rider::set_pos2d(Vector2d pos) { _pos2d = pos; }

void Rider::set_cda_factor(double cda_factor_) {
  cda_factor = cda_factor_;
  effective_cda = cda_factor * cda;
  compute_drag();
}

void Rider::set_mass(double rider_mass) {
  mass = rider_mass;
  total_mass = rider_mass + bike.mass;
  compute_coeff();
}

void Rider::compute_headwind() {
  Wind wind = course->get_wind(pos);
  v_hw = wind.speed * cos(wind.heading - this->heading);
}

void Rider::compute_drag() {
  drag_coeff = 0.5 * RHO * (effective_cda + bike.wheel_drag_factor);
}

void Rider::compute_roll() { roll_coeff = bike.crr * total_mass * G; }

void Rider::compute_inertia() {
  mass_ir = total_mass + bike.wheel_i / pow(bike.wheel_r, 2);
  inertia_coeff = 0.5 * mass_ir;
}

void Rider::compute_coeff() {
  compute_drag();
  compute_roll();
  compute_inertia();
}

void Rider::change_bike(Bike new_bike) {
  bike = new_bike;
  total_mass = mass + bike.mass;
  f_grav = total_mass * G;
  compute_coeff();
}

void Rider::reset() {
  pos = 0;
  speed = 0;
  // TODO - reset energymodel!
}

void Rider::update(double dt) {
  timestep = dt;
  slope = course->get_slope(pos);
  compute_headwind();
  double ftp = ftp_base;
  // this comes from energymodel
  double effort_limit = 1;
  effort = target_effort;
  power = std::min(target_effort, effort_limit) * ftp;
  // energy_model.update(power, timestep);
  try {
    double old_speed = speed;
    speed = newton(power, speed);
    update_power_breakdown(old_speed);
  } catch (std::exception& e) {
    SDL_Log("oops! %s", e.what());
    // TODO -  what here?
  }
  pos += timestep * speed;
  altitude = course->get_altitude(pos);
  set_pos2d(Vector2d{pos, altitude});
}

void Rider::set_effort(double new_effort) { target_effort = new_effort; }

// these 2 are a bit odd, no?
double Rider::km() const { return pos / 1000.0; }

double Rider::km_h() const { return speed * 3.6; }

void Rider::update_power_breakdown(double old_speed) {
  auto [wind_dir, wind_speed] = course->get_wind(pos);
  double v_rel_wind = wind_speed * std::cos(wind_dir - heading);

  double v_air = speed + v_rel_wind;

  power_breakdown[(int)PowerTerm::Aerodynamic] =
      drag_coeff * pow(v_air, 2) * speed;
  power_breakdown[(int)PowerTerm::Rolling] = roll_coeff * speed;
  power_breakdown[(int)PowerTerm::Bearings] = (0.091 + 0.0087 * speed) * speed;
  power_breakdown[(int)PowerTerm::Gravity] = f_grav * sin(atan(slope)) * speed;
  power_breakdown[(int)PowerTerm::Inertia] =
      inertia_coeff * (pow(speed, 2) - pow(old_speed, 2)) / timestep;
  // sum without Drivetrain loss
  double sum_raw = std::accumulate(
      power_breakdown.begin(),
      power_breakdown.begin() + (int)PowerTerm::Drivetrain, 0.0);

  power_breakdown[(int)PowerTerm::Drivetrain] = sum_raw * bike.dt_loss;

  double total =
      std::accumulate(power_breakdown.begin(), power_breakdown.end(), 0.0);
  if (std::abs(total - power) > 0.2) {
    SDL_Log("%.2f", total - power);
    SDL_Log("%.2f", sum_raw);
    SDL_Log("%.2f", total);
  }
}

double Rider::pow_speed(double new_speed) {
  auto [wind_dir, wind_speed] = course->get_wind(pos);
  double v_rel_wind = wind_speed * std::cos(wind_dir - heading);

  double v_air = new_speed + v_rel_wind;

  return (drag_coeff * pow(v_air, 2) * new_speed + roll_coeff * new_speed +
          (0.091 + 0.0087 * new_speed) * new_speed +
          f_grav * sin(atan(slope)) * new_speed +
          inertia_coeff * (pow(new_speed, 2) - pow(speed, 2)) / timestep) /
         (1 - bike.dt_loss);
}

double Rider::pow_speed_prime(double new_speed) const {
  auto [wind_dir, wind_speed] = course->get_wind(pos);
  double v_rel_wind = wind_speed * std::cos(wind_dir - heading);

  double v_air = new_speed + v_rel_wind;
  return (drag_coeff * (2 * v_air * new_speed + pow(v_air, 2)) + roll_coeff +
          0.091 + 0.0174 * new_speed + f_grav * sin(atan(slope)) +
          inertia_coeff * 2 * new_speed / timestep) /
         (1 - bike.dt_loss);
}

double Rider::pow_speed_double_prime(double new_speed) const {
  auto [wind_dir, wind_speed] = course->get_wind(pos);
  double v_rel_wind = wind_speed * std::cos(wind_dir - heading);

  double v_air = new_speed + v_rel_wind;
  return (drag_coeff * (2 * new_speed + 4 * v_air) + 0.0174 +
          inertia_coeff * 2 / timestep) /
         (1 - bike.dt_loss);
}

double Rider::newton(double power, double speed_guess, int max_iterations) {
  double x = speed_guess;
  double x_next;
  double f, f_prime;

  for (int i = 0; i < max_iterations; ++i) {
    f = pow_speed(x) - power;
    f_prime = pow_speed_prime(x);

    if (std::abs(f_prime) < 1e-12) {
      throw std::runtime_error("Derivative too small.");
    }

    x_next = x - f / f_prime;

    // std::cout << "error: " << f << "\tprecision: " << x_next - x <<
    // std::endl;

    if (is_close(f, 0, ETOL, ERTOL) || is_close(x_next, x, PTOL, PRTOL)) {
      return x_next;
    }

    x = x_next;
  }

  throw std::runtime_error("Did not converge. Reached max iterations: " +
                           std::to_string(max_iterations));
}

double Rider::householder(double power, double speed_guess,
                          int max_iterations) {
  double x = speed_guess;
  double x_next;
  double f, f_prime, f_double_prime;

  for (int i = 0; i < max_iterations; ++i) {
    f = pow_speed(x) - power;
    f_prime = pow_speed_prime(x);
    f_double_prime = pow_speed_double_prime(x); // must define this

    if (std::abs(f_prime) < 1e-12) {
      throw std::runtime_error("Derivative too small.");
    }

    double correction = (f / f_prime);
    correction *= (1.0 + (f * f_double_prime) / (2.0 * f_prime * f_prime));

    x_next = x - correction;

    std::cout << "error: " << f << "\tprecision: " << x_next - x << std::endl;

    if (is_close(f, 0, ETOL, ERTOL) || is_close(x_next, x, PTOL, PRTOL)) {
      return x_next;
    }

    x = x_next;
  }

  throw std::runtime_error("Did not converge. Reached max iterations: " +
                           std::to_string(max_iterations));
}

RiderSnapshot Rider::snapshot() const {
  return RiderSnapshot{
      .uid = this->uid,
      .name = this->name,
      .pos = this->pos,
      .slope = this->slope,
      .pos2d = this->_pos2d,
      .power = this->power,
      .effort = this->effort,
      .max_effort = this->max_effort,
      .speed = this->speed,
      .km_h = this->km_h(),
      .heading = this->heading,
      .team_id = this->team.id,
      .visual_type = this->bike.type,
      .power_breakdown = this->power_breakdown,
  };
}
```

src/screen.cpp
```
#include "screen.h"
#include "SDL3/SDL_log.h"
#include "appstate.h"
#include "backends/imgui_impl_sdl3.h"
#include "backends/imgui_impl_sdlrenderer3.h"
#include "imgui.h"
#include "plotrenderer.h"
#include "screenmanager.h"
#include "simulationrenderer.h"
#include "snapshot.h"
#include "widget.h"
#include <memory>

void MenuScreen::render() {
  SDL_SetRenderDrawColor(state->renderer, 30, 30, 30, 255);
  SDL_RenderClear(state->renderer);

  // draw a simple "Press ENTER" text
  // you probably have font rendering already via resources

  SDL_RenderPresent(state->renderer);
}

void ResultsScreen::render() {
  SDL_SetRenderDrawColor(state->renderer, 0, 0, 0, 255);
  SDL_RenderClear(state->renderer);

  // show rider stats
  // auto snap1 = state->sim->get_engine()->snapshot_of(state->r1);
  // auto snap2 = state->sim->get_engine()->snapshot_of(state->r2);

  // draw simple text:
  // "Rider1 final pos: 123.4"
  // "Rider2 final pos: 110.2"

  SDL_RenderPresent(state->renderer);
}

SimulationScreen::SimulationScreen(AppState* s) : state(s) {
  Vector2d screensize(s->SCREEN_WIDTH, s->SCREEN_HEIGHT);
  // maybe this could take screensize rather than 2 ints?
  // display = new DisplayEngine(state, screensize, WORLD_WIDTH);
  auto cam = std::make_shared<Camera>(s->course, WORLD_WIDTH, screensize);
  sim_renderer = std::make_unique<SimulationRenderer>(s->renderer, s->resources,
                                                      s->sim, cam);

  TTF_Font* default_font =
      state->resources->get_fontManager()->get_font("default");

  sim_renderer->add_world_drawable(
      std::make_unique<CourseDrawable>(state->sim->get_engine()->get_course()));
  sim_renderer->add_world_drawable(std::make_unique<RiderDrawable>());

  sim_renderer->add_drawable(std::make_unique<Stopwatch>(
      20, 20, state->resources->get_fontManager()->get_font("stopwatch"),
      state->sim));

  sim_renderer->add_drawable(std::make_unique<TimeControlPanel>(
      400, 20, 40, default_font, state->sim));

  // 2. Create the Panel
  auto panel = std::make_unique<RiderPanel>(20, 120, default_font);

  // 3. Add Rows (Using Lambdas for custom logic)

  // SPEED
  panel->add_row("Speed", "km/h", [](const RiderSnapshot& s) {
    return format_number(s.km_h, 2);
  });

  // POWER
  panel->add_row("Power", "W", [](const RiderSnapshot& s) {
    return format_number(s.power, 0); // Precision 0 for watts
  });

  // DISTANCE
  panel->add_row("Dist", "km", [](const RiderSnapshot& s) {
    return format_number(s.pos / 1000.0);
  });

  // GRADIENT (Custom logic inside lambda!)
  panel->add_row("Grad", "%", [](const RiderSnapshot& s) {
    // Assuming you add 'slope' to RiderSnapshot
    // return format_number(s.slope * 100.0);
    return format_number(s.slope * 100.0);
  });

  RiderPanel* p = panel.get();

  sim_renderer->set_rider_panel(p);
  sim_renderer->add_drawable(std::move(panel));

  auto num = std::make_unique<EditableNumberField>(
      200, 400, 80, 26, default_font, state->window, [&](double v) {
        Rider* r = state->sim->get_engine()->get_rider(0);
        r->set_effort(v);
        SDL_Log("%s effort set to %d %%", r->name.c_str(), int(100 * v));
      });

  sim_renderer->add_drawable(std::move(num));

  auto name_field = std::make_unique<EditableStringField>(
      200, 450, 120, 26, default_font, state->window,
      [&](const std::string& s) { SDL_Log("%s", s.c_str()); });

  sim_renderer->add_drawable(std::move(name_field));
}

SimulationScreen::~SimulationScreen() = default;

void SimulationScreen::update() { sim_renderer->update(); }

void SimulationScreen::render() {
  ImGui_ImplSDLRenderer3_NewFrame();
  ImGui_ImplSDL3_NewFrame();
  ImGui::NewFrame();

  sim_renderer->render_frame();

  // 3) Now have ImGui render its draw data
  ImGui::Render();
  ImGui_ImplSDLRenderer3_RenderDrawData(ImGui::GetDrawData(), state->renderer);

  // 4) Finally present
  SDL_RenderPresent(state->renderer);
}

bool SimulationScreen::handle_event(const SDL_Event* e) {
  if (sim_renderer->handle_event(e))
    return true;

  switch (e->type) {
  case SDL_EVENT_MOUSE_BUTTON_DOWN:
    if (e->button.button == SDL_BUTTON_LEFT) {
      int uid = sim_renderer->pick_rider(e->button.x, e->button.y);

      if (uid != -1) {
        selected_rider_uid = uid;
        // sim_renderer->get_camera()->set_target(uid);
        sim_renderer->get_camera()->set_target_id(uid);
        sim_renderer->get_rider_panel()->set_rider_id(uid);
        return true;
      }
    }
    if (e->button.button == SDL_BUTTON_RIGHT) {
      // Start dragging for camera pan
      dragging = true;
      drag_start_x = e->button.x;
      drag_start_y = e->button.y;
      return true;
    }
    break;

    // button released
  case SDL_EVENT_MOUSE_BUTTON_UP:
    if (e->button.button == SDL_BUTTON_RIGHT) {
      dragging = false;
      return true;
    }
    break;

  case SDL_EVENT_MOUSE_WHEEL: {
    constexpr double ZOOM_SENSITIVITY = 0.1;
    sim_renderer->get_camera()->zoom(e->wheel.y * ZOOM_SENSITIVITY);
    return true;
  }

  case SDL_EVENT_KEY_DOWN:
    switch (e->key.key) {
    case SDLK_LEFT:
      cycle_rider(-1);
      return true;

    case SDLK_RIGHT:
      cycle_rider(+1);
      return true;

    case SDLK_ESCAPE:
      state->screens->replace(ScreenType::Menu);
      return true;
    }
    break;
  }
  return false;
}

void SimulationScreen::cycle_rider(int direction) {
  const auto& riders = sim_renderer->get_frame_pair().curr->riders;
  if (riders.empty())
    return;

  // Extract IDs into a sorted list for stable cycling
  std::vector<int> ids;
  ids.reserve(riders.size());
  for (const auto& [id, _] : riders)
    ids.push_back(id);

  std::sort(ids.begin(), ids.end());

  // Find current index
  auto it = std::find(ids.begin(), ids.end(), selected_rider_uid);
  int idx = (it == ids.end()) ? 0 : std::distance(ids.begin(), it);

  // Cycle with wrap-around
  idx = (idx + direction + ids.size()) % ids.size();

  selected_rider_uid = ids[idx];

  // Apply selection
  sim_renderer->get_camera()->set_target_id(selected_rider_uid);
  sim_renderer->get_rider_panel()->set_rider_id(selected_rider_uid);
}

PlotScreen::PlotScreen(AppState* s) : state(s) {
  renderer = std::make_unique<PlotRenderer>(state->renderer, state->resources);

  TTF_Font* f = state->resources->get_fontManager()->get_font("default");

  renderer->add_drawable(std::make_unique<Button>(
      20, 20, 120, 30, "Back to simulation", f,
      [this]() { state->screens->replace(ScreenType::Simulation); }));

  renderer->add_drawable(
      std::make_unique<Button>(20, 60, 120, 30, "Pause", f, [this]() {
        auto sim = state->sim;
        if (sim->is_paused())
          sim->resume();
        else
          sim->pause();
      }));
}

PlotScreen::~PlotScreen() = default;

void PlotScreen::update() { ; }

void PlotScreen::render() { renderer->render_frame(); }

bool PlotScreen::handle_event(const SDL_Event* e) {
  if (renderer->handle_event(e))
    return true;

  if (e->type == SDL_EVENT_KEY_DOWN && e->key.key == SDLK_ESCAPE) {
    state->screens->replace(ScreenType::Simulation);
    return true;
  }
  return false;
}
```

src/screenmanager.cpp
```
#include "screenmanager.h"
#include "appstate.h"
#include "screen.h"

ScreenManager::ScreenManager(AppState* state) : app(state) {}

std::unique_ptr<IScreen> ScreenManager::create_screen(ScreenType type) {
  switch (type) {
  case ScreenType::Menu:
    return std::make_unique<MenuScreen>(app);
  case ScreenType::Simulation:
    return std::make_unique<SimulationScreen>(app);
  case ScreenType::Result:
    return std::make_unique<ResultsScreen>(app);
  case ScreenType::Plot:
    return std::make_unique<PlotScreen>(app);
  }
  return nullptr;
}

void ScreenManager::push(ScreenType type) {
  // stack.push_back(create_screen(type));
  pending.type = PendingActionType::Push;
  pending.screen = type;
}

void ScreenManager::pop() {
  // if (!stack.empty()) {
  //   stack.pop_back();
  // }
  pending.type = PendingActionType::Pop;
}

void ScreenManager::replace(ScreenType type) {
  // pop();
  // push(type);
  pending.type = PendingActionType::Replace;
  pending.screen = type;
}

void ScreenManager::handle_event(const SDL_Event* e) {
  if (!stack.empty()) {
    stack.back()->handle_event(e);
  }
}

void ScreenManager::update() {
  // --- 1. Apply queued transition BEFORE updating top screen ---
  if (pending.type != PendingActionType::None) {
    switch (pending.type) {
    case PendingActionType::Push:
      stack.push_back(create_screen(pending.screen));
      break;

    case PendingActionType::Pop:
      if (!stack.empty())
        stack.pop_back();
      break;

    case PendingActionType::Replace:
      if (!stack.empty())
        stack.pop_back();
      stack.push_back(create_screen(pending.screen));
      break;

    default:
      break;
    }

    pending.type = PendingActionType::None;
  }

  // --- 2. Now update current top screen safely ---
  if (!stack.empty()) {
    stack.back()->update();
  }
  // or if we add modal
  // for (auto& s : stack)
  // if (s->is_modal()) break;
  // else s->update();
  // screens get virtual bool is_modal()
}

void ScreenManager::render() {
  // Important: render *all* screens if you want overlays.
  for (auto& s : stack)
    s->render();
}
```

src/sim.cpp
```
#include "sim.h"
#include <chrono>
#include <thread>

PhysicsEngine::PhysicsEngine(const Course* c) : course(c) {}

void PhysicsEngine::add_rider(Rider* r) {
  for (Rider* r0 : riders) {
    if (r->get_id() == r0->get_id()) {
      SDL_Log("Tried to add rider who is already in the list! %s",
              r->name.c_str());
      return;
    }
  }
  std::lock_guard<std::mutex> lock(frame_mtx);
  riders.push_back(r);
  r->set_course(course);
}

void PhysicsEngine::update(double dt) {
  for (Rider* r : riders) {
    r->update(dt);
    // std::cout << "pos: " << r->pos << "\tm\nspeed: " << 3.6 * r->speed <<
    // "\tkm/h\n" << std::endl;
  }
}

// Expose a way for the render thread to grab the same mutex.
// We need this so that rendering can “lock frame_mtx” before reading any Rider
// state.
std::mutex* PhysicsEngine::get_frame_mutex() const { return &frame_mtx; }

const std::vector<Rider*>& PhysicsEngine::get_riders() const { return riders; }

// this is (now) only used to set camera to first rider... kinda useless if
// fixed
Rider* PhysicsEngine::get_rider(int idx) const { return riders.at(idx); }

PhysicsEngine::~PhysicsEngine() {
  // WARNING - if riders have textures or other dependencies
  // we need to be careful here
  for (Rider* r : riders) {
    delete r;
  }
}

Simulation::Simulation(const Course* c) : engine(c) {}

void Simulation::start_realtime() {
  running = true;
  double accumulator = 0.0;
  double sim_step;

  auto t_prev = std::chrono::steady_clock::now();

  while (running) {
    if (paused) {
      t_prev = std::chrono::steady_clock::now();
      std::this_thread::sleep_for(std::chrono::milliseconds(1));
      continue;
    }

    auto t_now = std::chrono::steady_clock::now();
    double frame_time = std::chrono::duration<double>(t_now - t_prev).count();
    t_prev = t_now;

    accumulator += frame_time * time_factor;
    if (accumulator > 0.25) {
      SDL_Log("accumulator %f > 0.25 s. Setting to 0.25s.", accumulator);
      accumulator = 0.25;
    }

    while (accumulator >= dt) {
      auto step_start = std::chrono::steady_clock::now();

      try {
        step_fixed(dt);
      } catch (const std::exception& e) {
        physics_error = true;
        physics_error_message = e.what();
        running = false;
      }
      accumulator -= dt;

      // what follows is only to check for exceeding the time
      auto step_end = std::chrono::steady_clock::now();
      double step_time =
          std::chrono::duration<double>(step_end - step_start).count();
      if (step_time > dt) {
        SDL_Log("Hey! engine.update(dt=%f) took %f. spiral of death!", dt,
                step_time);
      }
    }
    // interp_alpha = accumulator / dt;

    // After you’ve done zero or more physics steps,
    // you can sleep a tiny bit (to release thread?)
    std::this_thread::sleep_for(std::chrono::milliseconds(1));
  }
}

void Simulation::step_fixed(double dt) {
  std::lock_guard<std::mutex> phys_lock(*engine.get_frame_mutex());
  engine.update(dt);
  sim_seconds += dt;
}

void Simulation::run_max_speed(const SimulationCondition& cond) {
  using namespace std::chrono;

  const int secs = 180;
  const auto timeout = seconds(secs);
  const auto start_time = steady_clock::now();
  int iteration = 1;

  while (!cond.is_met(*this)) {
    try {
      step_fixed(dt);
    } catch (const std::exception& e) {
      physics_error = true;
      physics_error_message = e.what();
      break;
    }

    if (++iteration % 100 == 0) {
      if (steady_clock::now() - start_time > timeout) {
        SDL_Log("Timeout %d seconds after %d iterations", secs, iteration);
        break;
      }
    }
  }
}

void Simulation::pause() { paused = true; }

void Simulation::resume() { paused = false; }

bool Simulation::is_paused() const { return paused; }

void Simulation::stop() { running = false; }

const double Simulation::get_sim_seconds() const { return sim_seconds; }

class TimeReached : public SimulationCondition {
  double limit;

public:
  explicit TimeReached(double limit_seconds) : limit(limit_seconds) {}

  bool is_met(const Simulation& sim) const override {
    return sim.get_sim_seconds() >= limit;
  }
};

class RiderFinished : public SimulationCondition {
  int rider_index;

public:
  RiderFinished(int idx) : rider_index(idx) {}

  bool is_met(const Simulation& sim) const override {
    std::vector<Rider*> riders = sim.get_engine()->get_riders();
    bool met = false;
    for (Rider* r : riders) {
      if (r->pos >= sim.get_engine()->get_course_length()) {
        met = true;
      }
    }
    return met;
  }
};

const PhysicsEngine* Simulation::get_engine() const { return &engine; }
PhysicsEngine* Simulation::get_engine() { return &engine; }
```

src/simulationrenderer.cpp
```
#include "simulationrenderer.h"
#include "camera.h"
#include "display.h"
#include "sim.h"
#include <memory>
#include <mutex>

SimulationRenderer::SimulationRenderer(SDL_Renderer* r,
                                       GameResources* resources,
                                       Simulation* sim_,
                                       std::shared_ptr<Camera> cam)
    : CoreRenderer(r, resources), sim(sim_), camera(std::move(cam)) {
  build_and_swap_snapshots();
  // this could probably be removed
  if (frame_curr.riders.count(0)) {
    camera->set_center(frame_curr.riders.at(0).pos2d);
  }
}

void SimulationRenderer::add_world_drawable(std::unique_ptr<Drawable> d) {
  world_drawables.push_back(std::move(d));
}

void SimulationRenderer::build_and_swap_snapshots() {
  // Build into frame_back (no lock needed if frame_back is not shared)
  frame_back.riders.clear();

  // sim->fill_snapshots(frame_back.riders); // however you currently do it
  // could extract this into a function (gpt says it lives inside Simulation)
  PhysicsEngine* engine = sim->get_engine();
  {
    // protects only reading rider data
    std::lock_guard<std::mutex> phys_lock(*engine->get_frame_mutex());

    const auto& riders = engine->get_riders();
    for (const Rider* r : riders) {
      if (!r)
        continue;
      frame_back.riders.emplace(r->get_id(), r->snapshot());
    }
  }

  frame_back.sim_time = sim->get_sim_seconds();
  frame_back.sim_dt = sim->get_dt();
  frame_back.time_factor = sim->get_time_factor(); // or wherever it lives
  frame_back.real_time = SDL_GetTicks() / 1000.0;

  // Only publish if sim advanced
  {
    std::scoped_lock lock(snapshot_swap_mtx);

    if (!frames_initialized) {
      frame_curr = frame_back;
      frame_prev = frame_back; // identical on purpose
      frames_initialized = true;
      return;
    }

    if (frame_back.sim_time <= frame_curr.sim_time) {
      return; // no new sim step -> keep prev/curr stable for interpolation
    }
    frame_prev = std::move(frame_curr);
    frame_curr = std::move(frame_back);
  }
}

void SimulationRenderer::update() {
  // First gather snapshots
  build_and_swap_snapshots();
}

void SimulationRenderer::render_frame() {
  SDL_SetRenderDrawColor(renderer, 30, 30, 30, 255);
  SDL_RenderClear(renderer);

  RenderContext ctx;
  ctx.renderer = renderer;
  ctx.resources = resources;
  ctx.camera_weak = camera;
  ctx.sim_time = sim->get_sim_seconds();

  double now = SDL_GetTicks() / 1000.0;

  {
    // IMPORTANT: prevent swap while we compute alpha and set pointers
    std::scoped_lock lock(snapshot_swap_mtx);

    ctx.prev_frame = &frame_prev;
    ctx.curr_frame = &frame_curr;

    const double sim_dt = frame_curr.sim_time - frame_prev.sim_time;

    // time since "curr" was published (real seconds)
    const double real_since_curr = now - frame_curr.real_time;

    double alpha = 1.0;
    if (sim_dt > 0.0) {
      alpha = (real_since_curr * frame_curr.time_factor) / sim_dt;
    }
    ctx.alpha = std::clamp(alpha, 0.0, 1.0);

    InterpolatedFrameView view;
    view.alpha = alpha;
    view.interp_sim_time =
        frame_prev.sim_time * (1.0 - alpha) + frame_curr.sim_time * alpha;

    for (const auto& [id, s1] : frame_curr.riders) {
      auto it0 = frame_prev.riders.find(id);
      if (it0 == frame_prev.riders.end())
        continue;

      const RiderSnapshot& s0 = it0->second;

      view.rider_pos[id] = s0.pos2d * (1.0 - alpha) + s1.pos2d * alpha;

      view.rider_slope[id] = s0.slope * (1.0 - alpha) + s1.slope * alpha;

      view.rider_effort[id] = s0.effort * (1.0 - alpha) + s1.effort * alpha;
    }

    ctx.view = std::move(view);
  }

  camera->update(ctx.view);

  // 1. Draw world-space drawables
  int cnt = 0;
  for (auto& d : world_drawables) {
    d->render(&ctx);
  }

  // 2. Draw UI drawables (inherited from CoreRenderer)
  cnt = 0;
  for (auto& d : drawables) {
    d->render(&ctx);
  }

  for (auto& w : drawables)
    w->render_imgui(&ctx);
}

// TODO - make this safe - there is a suggestion in "Code review feedback" chat
// in chatGPT from 26.11.2025
int SimulationRenderer::pick_rider(double screen_x, double screen_y) const {
  if (!camera)
    return -1;

  Vector2d world_pos = camera->screen_to_world(Vector2d(screen_x, screen_y));

  double min_dist = 20.0;
  bool found = false;
  size_t found_id = 0;
  SDL_Log("\n%.1f, %.1f", world_pos.x(), world_pos.y());

  std::lock_guard<std::mutex> lock(snapshot_swap_mtx);
  for (auto& [id, snap] : frame_curr.riders) {
    double dx = snap.pos2d.x() - world_pos.x();
    double dy = snap.pos2d.y() - world_pos.y();
    double dist = std::sqrt(dx * dx + dy * dy);
    SDL_Log("%s: %.1f", snap.name.c_str(), dist);

    // you might wanna weight X more strictly if they are packed tight
    if (dist < min_dist) {
      min_dist = dist;
      found_id = id;
      found = true;
    }
  }

  if (found) {
    SDL_Log("Selected rider ID: %lu", (unsigned long)found_id);
    return found_id;
  }
  return -1;
}

FramePairView SimulationRenderer::get_frame_pair() const {
  std::scoped_lock lock(snapshot_swap_mtx);

  return FramePairView{.prev = &frame_prev, .curr = &frame_curr};
}

bool SimulationRenderer::handle_event(const SDL_Event* e) {
  // UI above world
  for (auto& d : drawables)
    if (d->handle_event(e))
      return true;

  for (auto& d : world_drawables)
    if (d->handle_event(e))
      return true;

  return false;
}
```

src/texturemanager.cpp
```
#include "texturemanager.h"
#include "SDL3_ttf/SDL_ttf.h"
#include <SDL3/SDL.h>
#include <SDL3_image/SDL_image.h>
#include <iostream>
#include <unordered_map>

// You must give TextureManager a valid SDL_Renderer* at construction time.
// It keeps that renderer internally so it can turn surfaces → textures.
TextureManager::TextureManager(SDL_Renderer* renderer) : renderer(renderer) {}

TextureManager::~TextureManager() {
  // Destroy all SDL_Texture* that we have loaded.
  for (auto& kv : texture_map) {
    if (kv.second) {
      SDL_DestroyTexture(kv.second);
    }
  }
}

// Try to load a texture from `filePath` and store it under the key `id`.
// Returns true if successful (or if the key already existed).
bool TextureManager::load_texture(const char* id, const char* file_path) {
  // If we've already loaded “id”, do nothing.
  if (texture_map.count(id)) {
    return true;
  }

  SDL_Surface* surf = IMG_Load(file_path);
  if (!surf) {
    std::cerr << "IMG_Load Error (" << file_path << "): " << SDL_GetError()
              << "\n";
    return false;
  }

  SDL_Texture* tex = SDL_CreateTextureFromSurface(renderer, surf);
  SDL_DestroySurface(surf);

  if (!tex) {
    std::cerr << "SDL_CreateTextureFromSurface Error (" << file_path
              << "): " << SDL_GetError() << "\n";
    return false;
  }

  texture_map[id] = tex;
  return true;
}

// Retrieve the texture pointer for a given id (returns nullptr if not found).
TTF_Font* FontManager::get_font(const char* id) const {
  auto it = font_map.find(id);
  if (it == font_map.end())
    return nullptr;
  return it->second;
}

// (Optional) Query width/height of a loaded texture.
bool TextureManager::query_texture(const char* id, float& outW,
                                   float& outH) const {
  SDL_Texture* tex = get_texture(id);
  if (!tex)
    return false;
  if (0 != SDL_GetTextureSize(tex, &outW, &outH)) {
    std::cerr << "SDL_QueryTexture Error: " << SDL_GetError() << "\n";
    return false;
  }
  return true;
}

// Retrieve the texture pointer for a given id (returns nullptr if not found).
SDL_Texture* TextureManager::get_texture(const char* id) const {
  auto it = texture_map.find(id);
  if (it == texture_map.end())
    return nullptr;
  return it->second;
}

bool FontManager::load_font(const char* id, const char* file_path,
                            int font_size) {
  if (font_map.count(id)) {
    return true;
  }

  char* font_path = NULL;
  SDL_asprintf(&font_path, "%s/../%s", SDL_GetBasePath(), file_path);
  TTF_Font* font = TTF_OpenFont(font_path, font_size);
  if (!font) {
    SDL_Log("Couldn't load font: %s", SDL_GetError());
    return false;
  }
  SDL_free(font_path);

  font_map[id] = font;
  return true;
}

FontManager::~FontManager() {
  // Destroy all SDL_Texture* that we have loaded.
  for (auto& kv : font_map) {
    if (kv.second) {
      // free(kv.second);
      TTF_CloseFont(kv.second);
    }
  }
}
```

src/widget.cpp
```
#include <SDL3/SDL.h>
#include <SDL3_ttf/SDL_ttf.h>
#include <algorithm>
#include <cstdio>
#include <memory>
#include <string>

#include "SDL3/SDL_log.h"
#include "SDL3/SDL_pixels.h"
#include "SDL3/SDL_rect.h"
#include "SDL3/SDL_render.h"
#include "SDL3/SDL_surface.h"
#include "display.h"
#include "imgui.h"
#include "implot.h"
#include "snapshot.h"
#include "widget.h"
// for std::setprecision
// #include <iomanip>

std::string format_number(double value, int precision) {
  char buffer[32];
  snprintf(buffer, sizeof(buffer), "%.*f", precision, value);
  return std ::string(buffer);
}

void format_time(double seconds, char* text) {
  // Break down into components
  int totalTenths = static_cast<int>(round(seconds * 10));
  int tenths = totalTenths % 10;
  int totalSeconds = totalTenths / 10;
  int secs = totalSeconds % 60;
  int totalMinutes = totalSeconds / 60;
  int mins = totalMinutes % 60;
  int hours = totalMinutes / 60;

  // Format with leading zeros and fixed positions
  snprintf(text, 11, "%02d:%02d:%02d.%d", hours, mins, secs, tenths);
}

// std::pair<int, int> Widget::get_texture_size() const {
//   return {widget_w, widget_h};
// }

SDL_Texture* Stopwatch::render_time(SDL_Renderer* renderer, const char* s,
                                    int& out_w, int& out_h) {
  SDL_Surface* surf =
      TTF_RenderText_LCD(font, s, 0, text_color, SDL_Color{0, 0, 0, 200});
  if (!surf) {
    SDL_Log("TTF_RenderText_LCD failed: %s", SDL_GetError());
    return nullptr;
  }
  out_w = surf->w;
  out_h = surf->h;

  SDL_Texture* new_texture = SDL_CreateTextureFromSurface(renderer, surf);
  SDL_DestroySurface(surf);

  if (!new_texture) {
    SDL_Log("SDL_CreateTextureFromSurface failed: %s", SDL_GetError());
    return nullptr;
  }
  return new_texture;
}

void Stopwatch::update_texture(const RenderContext* ctx) {
  double sim_time = sim->get_sim_seconds();
  format_time(sim_time, text);

  if (texture) {
    SDL_DestroyTexture(texture);
    texture = nullptr;
  }
  texture = render_time(ctx->renderer, text, width, height);
}

void Stopwatch::render(const RenderContext* ctx) {
  // 1) Check if we need to build the background frame
  if (bg_texture == nullptr) {
    bg_texture = create_base(ctx->renderer);
  }

  // 2) Check if we need to update the time digits
  Uint32 now_ticks = SDL_GetTicks();
  if (texture == nullptr || (now_ticks - last_update_ticks) >=
                                static_cast<Uint32>(update_interval_ms)) {
    update_texture(ctx);
    last_update_ticks = now_ticks;
  }

  // 3) Draw Background Frame
  if (bg_texture) {
    // Note: The background includes padding, so it is larger than the text
    SDL_FRect dst{static_cast<float>(screen_x), static_cast<float>(screen_y),
                  static_cast<float>(bg_width), static_cast<float>(bg_height)};
    SDL_RenderTexture(ctx->renderer, bg_texture, nullptr, &dst);
  }

  // 4) Draw Text (inset by content_offset)
  if (texture) {
    // Note: width/height here refers to the BACKGROUND dimensions calculated in
    // create_base. We use texture size from the text itself for the source? No,
    // render_time set width/height? Wait, render_time sets 'width' and 'height'
    // MEMBER variables which overwrites the background size? FIX: The member
    // variables `width` and `height` should likely store the total widget size.
    // But render_time takes `width` and `height` by reference as `out_w`,
    // `out_h`.

    // Let's inspect the logic:
    // create_base sets `width` and `height` to the padded size.
    // update_texture calls render_time(..., width, height).
    // This effectively overwrites the widget size with the text size every
    // update! That is a bug in the provided code snippet, but I will implement
    // it as requested while fixing the overwrite to use local variables for the
    // text size so the background doesn't shrink.

    float txt_w, txt_h;
    SDL_GetTextureSize(texture, &txt_w, &txt_h);

    SDL_FRect dst = {static_cast<float>(screen_x + content_offset),
                     static_cast<float>(screen_y + content_offset),
                     static_cast<float>(txt_w), static_cast<float>(txt_h)};
    SDL_RenderTexture(ctx->renderer, texture, nullptr, &dst);
  }
}

SDL_Texture* Stopwatch::create_base(SDL_Renderer* renderer) {
  int w, h;
  // Calculate size based on a dummy string "00:00:00.0" to ensure fixed width
  TTF_GetStringSize(font, "00:00:00.0", 0, &w, &h);

  int padded_w = w + 2 * content_offset;
  int padded_h = h + 2 * content_offset;
  bg_width = padded_w;
  bg_height = padded_h;

  SDL_Surface* surf =
      SDL_CreateSurface(padded_w, padded_h, SDL_PIXELFORMAT_XRGB8888);
  if (!surf) {
    SDL_Log("SDL_CreateSurface failed: %s", SDL_GetError());
    return nullptr;
  }

  // Store the total size in member variables
  width = surf->w;
  height = surf->h;

  const SDL_PixelFormatDetails* fmt_details =
      SDL_GetPixelFormatDetails(surf->format);
  Uint32 transparent = SDL_MapRGBA(fmt_details, nullptr, 0, 0, 0, 0);
  Uint32 hlPix = SDL_MapRGBA(fmt_details, nullptr, 177, 177, 177, 255);
  Uint32 shPix = SDL_MapRGBA(fmt_details, nullptr, 77, 77, 77, 255);

  SDL_Rect r{0, 0, padded_w, padded_h};
  SDL_FillSurfaceRect(surf, &r, transparent);

  SDL_Rect topEdge = {0, 0, padded_w, edge_thickness};
  SDL_FillSurfaceRect(surf, &topEdge, hlPix);

  SDL_Rect leftEdge = {0, 0, edge_thickness, padded_h};
  SDL_FillSurfaceRect(surf, &leftEdge, hlPix);

  SDL_Rect bottomEdge = {0, padded_h - edge_thickness, padded_w,
                         edge_thickness};
  SDL_FillSurfaceRect(surf, &bottomEdge, shPix);

  SDL_Rect rightEdge = {padded_w - edge_thickness, 0, edge_thickness, padded_h};
  SDL_FillSurfaceRect(surf, &rightEdge, shPix);

  SDL_Texture* tex = SDL_CreateTextureFromSurface(renderer, surf);
  SDL_DestroySurface(surf);
  return tex;
}

Button::Button(int x_, int y_, int w_, int h_, std::string label_,
               TTF_Font* font_, Callback cb)
    : x(x_), y(y_), w(w_), h(h_), label(std::move(label_)), font(font_),
      on_click(std::move(cb)) {}

void Button::render(const RenderContext* ctx) {
  SDL_Renderer* r = ctx->renderer;

  // Colors
  if (pressed)
    SDL_SetRenderDrawColor(r, 60, 60, 60, 255);
  else if (hovered)
    SDL_SetRenderDrawColor(r, 90, 90, 90, 255);
  else
    SDL_SetRenderDrawColor(r, 70, 70, 70, 255);

  SDL_FRect bg{(float)x, (float)y, (float)w, (float)h};
  SDL_RenderFillRect(r, &bg);

  // Render text
  SDL_Surface* surf = TTF_RenderText_Blended(font, label.c_str(), 0,
                                             SDL_Color{255, 255, 255, 255});
  if (!surf)
    return;

  SDL_Texture* tex = SDL_CreateTextureFromSurface(r, surf);
  if (!tex) {
    SDL_DestroySurface(surf);
    return;
  }

  float tx = x + (w - surf->w) * 0.5f;
  float ty = y + (h - surf->h) * 0.5f;
  SDL_FRect dst{tx, ty, (float)surf->w, (float)surf->h};
  SDL_RenderTexture(r, tex, nullptr, &dst);

  SDL_DestroyTexture(tex);
  SDL_DestroySurface(surf);
}

bool Button::handle_event(const SDL_Event* e) {
  int mx, my;

  switch (e->type) {

  case SDL_EVENT_MOUSE_MOTION:
    mx = e->motion.x;
    my = e->motion.y;
    hovered = (mx >= x && mx <= x + w && my >= y && my <= y + h);
    return hovered;

  case SDL_EVENT_MOUSE_BUTTON_DOWN:
    if (e->button.button == SDL_BUTTON_LEFT && hovered) {
      pressed = true;
      return true;
    }
    break;

  case SDL_EVENT_MOUSE_BUTTON_UP:
    if (e->button.button == SDL_BUTTON_LEFT) {
      if (pressed && hovered)
        if (on_click)
          on_click(); // <-- fire callback

      pressed = false;
      return hovered; // consumed if inside
    }
    break;
  }

  return false;
}

PauseButton::PauseButton(int x, int y, int w, int h, Simulation* sim,
                         TTF_Font* font)
    : Button(x, y, w, h, sim->is_paused() ? "Resume" : "Pause", font, [sim]() {
        if (sim->is_paused())
          sim->resume();
        else
          sim->pause();
      }) {}

void PauseButton::render(const RenderContext* ctx) {
  // Update label before drawing
  // set_label(sim->is_paused() ? "Resume" : "Pause");

  Button::render(ctx);
}

double TimeFactorSlider::slider_to_factor(double t) {
  if (t <= neutral_point) {
    double s = t / neutral_point;
    return 0.1 + s * (1.0 - 0.1);
  } else {
    double s = (t - neutral_point) / neutral_point;
    return std::pow(10.0, s * 2.0); // 1 → 100
  }
}

double TimeFactorSlider::factor_to_slider(double f) {
  if (f <= 1.0) {
    double s = (f - 0.1) / (1.0 - 0.1);
    return s * neutral_point;
  } else {
    double s = std::log10(f) / 2.0;
    return neutral_point + s * neutral_point;
  }
}

void TimeFactorSlider::render(const RenderContext* ctx) {
  SDL_Renderer* r = ctx->renderer;

  // background bar
  SDL_SetRenderDrawColor(r, 120, 120, 120, 255);
  SDL_FRect bar{(float)x, (float)y + h * 0.4f, (float)w, h * 0.2f};
  SDL_RenderFillRect(r, &bar);

  // neutral point - factor = 1.0
  float markerX = x + neutral_point * w - marker_width / 2.0;
  SDL_SetRenderDrawColor(r, 120, 120, 120, 255);
  SDL_FRect marker{markerX, (float)y, static_cast<float>(marker_width),
                   (float)h};
  SDL_RenderFillRect(r, &marker);

  // knob
  double t = factor_to_slider(sim->get_time_factor());
  float knobX = x + t * w - h / 4.0;
  SDL_SetRenderDrawColor(r, 240, 240, 240, 255);
  SDL_FRect knob{knobX, static_cast<float>(y + h / 4.0), (float)h / 2,
                 (float)h / 2};
  SDL_RenderFillRect(r, &knob);
}

bool TimeFactorSlider::handle_event(const SDL_Event* e) {
  switch (e->type) {
  case SDL_EVENT_MOUSE_BUTTON_DOWN:
    if (e->button.x >= x && e->button.x <= x + w && e->button.y >= y &&
        e->button.y <= y + h) {
      dragging = true;
      return true;
    }
    break;

  case SDL_EVENT_MOUSE_BUTTON_UP:
    dragging = false;
    break;

  case SDL_EVENT_MOUSE_MOTION:
    if (dragging) {
      double local = (e->motion.x - x) / (double)w;
      local = std::clamp(local, 0.0, 1.0);
      double f = slider_to_factor(local);
      sim->set_time_factor(f);
      return true;
    }
    break;
  }
  return false;
}

TimeControlPanel::TimeControlPanel(int x_, int y_, int h_, TTF_Font* font,
                                   Simulation* sim_)
    : x(x_), y(y_), h(h_), sim(sim_) {
  auto tf =
      std::make_unique<ValueField>(next_x, y + 2, valfield_w, h - 4, font);
  time_factor_field = tf.get();
  children.push_back(std::move(tf));
  next_x += valfield_w + gap_w;

  int widget_h = h_ / 2;
  int widget_y = y + h_ / 4;

  children.push_back(std::make_unique<TimeFactorSlider>(
      next_x, widget_y, slider_w, widget_h, sim));
  next_x += slider_w + gap_w;

  auto make_factor_button = [&](double val) {
    char buffer[50];
    snprintf(buffer, sizeof(buffer), "%.1f", val);
    std::string str = buffer; // "3.1"
    // children.push_back(std::make_unique<Button>(
    //     next_x, y + h_ / 4, button_w, h_ / 2, str + " ×", font,
    //     [sim_, val]() { sim_->set_time_factor(val); }));
    children.push_back(std::make_unique<TimeFactorButton>(
        next_x, widget_y, button_w, widget_h, val, sim_, font));
    next_x += gap_w + button_w;
  };

  make_factor_button(0.5);
  make_factor_button(1.0);
  make_factor_button(20.0);

  next_x += gap_w + button_w;
  children.push_back(std::make_unique<PauseButton>(next_x, widget_y, button_w,
                                                   widget_h, sim, font));
}

void TimeControlPanel::render(const RenderContext* ctx) {
  SDL_Renderer* r = ctx->renderer;

  // (Optional) panel background
  SDL_SetRenderDrawColor(r, 40, 40, 40, 200);
  SDL_FRect bg{
      (float)x, (float)y,
      static_cast<float>(valfield_w + slider_w + 3 * button_w + 6 * gap_w),
      static_cast<float>(h)};
  SDL_RenderFillRect(r, &bg);

  char buf[8];
  snprintf(buf, sizeof(buf), "%.2f", sim->get_time_factor());
  time_factor_field->set_text(buf);

  // Children
  for (auto& w : children)
    w->render(ctx);
}

bool TimeControlPanel::handle_event(const SDL_Event* e) {
  for (auto& w : children)
    if (w->handle_event(e))
      return true;

  return false;
}

ValueField::ValueField(int x_, int y_, int w_, int h_, TTF_Font* font_)
    : x(x_), y(y_), w(w_), h(h_), font(font_) {}

ValueField::~ValueField() {
  if (texture)
    SDL_DestroyTexture(texture);
  if (bg_texture)
    SDL_DestroyTexture(bg_texture);
}

void ValueField::set_text(const std::string& text) {
  if (text != current_text) {
    current_text = text;
    if (texture) {
      SDL_DestroyTexture(texture);
      texture = nullptr;
    }
  }
}

void ValueField::create_bg(SDL_Renderer* renderer) {
  SDL_Surface* surf = SDL_CreateSurface(w, h, SDL_PIXELFORMAT_RGBA32);
  SDL_FillSurfaceRect(surf, nullptr,
                      SDL_MapRGBA(SDL_GetPixelFormatDetails(surf->format),
                                  nullptr, 100, 100, 100, 200));
  bg_texture = SDL_CreateTextureFromSurface(renderer, surf);
  SDL_DestroySurface(surf);
}

void ValueField::update_texture(SDL_Renderer* renderer) {
  if (current_text.empty())
    return;

  SDL_Surface* surf =
      TTF_RenderText_Blended(font, current_text.c_str(), 0, text_color);
  if (!surf)
    return;

  texture = SDL_CreateTextureFromSurface(renderer, surf);
  SDL_DestroySurface(surf);
}

void ValueField::render(const RenderContext* ctx) {
  SDL_Renderer* renderer = ctx->renderer;

  if (!bg_texture)
    create_bg(renderer);

  if (!texture && !current_text.empty())
    update_texture(renderer);

  SDL_FRect rect{(float)x, (float)y, (float)w, (float)h};
  SDL_RenderTexture(renderer, bg_texture, nullptr, &rect);

  if (texture) {
    float tex_w, tex_h;
    SDL_GetTextureSize(texture, &tex_w, &tex_h);

    rect = SDL_FRect{(float)x + w - tex_w - 4, (float)y + (h - tex_h) * 0.5f,
                     (float)tex_w, (float)tex_h};

    SDL_RenderTexture(renderer, texture, nullptr, &rect);
  }
}

RiderValueField::RiderValueField(int x, int y, int w, int h, TTF_Font* font,
                                 size_t rider_id, DataGetter getter_)
    : ValueField(x, y, w, h, font), target_rider_id(rider_id), getter(getter_) {
}

void RiderValueField::render_with_snapshot(const RenderContext* ctx,
                                           const RiderSnapshot* snap) {
  if (!snap)
    return;

  std::string new_text = getter(*snap);
  set_text(new_text);

  // Use base render method
  render(ctx);
}

// ======================= METRIC ROW =======================

MetricRow::MetricRow(int x_, int y_, TTF_Font* f, size_t id, std::string label,
                     std::string unit, RiderValueField::DataGetter getter)
    : x(x_), y(y_), font(f), label_txt(label), unit_txt(unit) {

  // Create the child ValueField (Width 80, Height 24)
  // We position it relative to our X + label_width
  field = std::make_unique<RiderValueField>(x + label_width, y, 80, 24, font,
                                            id, getter);
}

MetricRow::~MetricRow() {
  if (label_tex)
    SDL_DestroyTexture(label_tex);
  if (unit_tex)
    SDL_DestroyTexture(unit_tex);
}

void MetricRow::set_position(int new_x, int new_y) {
  x = new_x;
  y = new_y;
  // Update child position
  field->set_position(x + label_width, y);
}

void MetricRow::render_for_rider(const RenderContext* ctx,
                                 const RiderSnapshot* snap) {
  // 1. Render static labels once
  if (!label_tex) {
    SDL_Surface* s = TTF_RenderText_Blended(font, label_txt.c_str(), 0,
                                            {200, 200, 200, 255});
    label_tex = SDL_CreateTextureFromSurface(ctx->renderer, s);
    SDL_DestroySurface(s);
  }
  if (!unit_tex && !unit_txt.empty()) {
    SDL_Surface* s =
        TTF_RenderText_Blended(font, unit_txt.c_str(), 0, {150, 150, 150, 255});
    unit_tex = SDL_CreateTextureFromSurface(ctx->renderer, s);
    SDL_DestroySurface(s);
  }

  // 2. Draw Label (Left)
  if (label_tex) {
    float w, h;
    SDL_GetTextureSize(label_tex, &w, &h);
    // Vertically center label relative to the row height (approx 24)
    SDL_FRect r = {(float)x, (float)y + (24 - h) / 2, w, h};
    SDL_RenderTexture(ctx->renderer, label_tex, nullptr, &r);
  }

  // Call the specific render on the field
  field->render_with_snapshot(ctx, snap);

  if (unit_tex) {
    float w, h;
    SDL_GetTextureSize(unit_tex, &w, &h);
    // Position: X + label + field_width + padding
    SDL_FRect r = {(float)(x + label_width + field->get_width() + 5),
                   (float)y + (24 - h) / 2, w, h};
    SDL_RenderTexture(ctx->renderer, unit_tex, nullptr, &r);
  }
}

// ======================= RIDER PANEL =======================
// WARNING - this assumes the font isnt deallocated
RiderPanel::RiderPanel(int x_, int y_, TTF_Font* f) : x(x_), y(y_), font(f) {}

void RiderPanel::set_rider_id(int uid) { rider_uid = uid; }

RiderPanel::~RiderPanel() {
  if (title_tex)
    SDL_DestroyTexture(title_tex);
}

void RiderPanel::add_row(std::string label, std::string unit,
                         RiderValueField::DataGetter getter) {
  int row_height = 30;                                // height + spacing
  int current_offset = rows.size() * row_height + 30; // +30 for title space

  // pass 0 as dummy, we overrider it
  // Ideally, MetricRow should also be refactored, but here is a
  // quick inheritance trick:

  // Better yet, let's make MetricRow dynamic too.
  // But to save refactoring EVERYTHING, let's use a "Dynamic ID" constant?
  // No, cleaner to just pass the ID in render.
  auto row = std::make_unique<MetricRow>(x, y + current_offset, font, 0, label,
                                         unit, getter);
  rows.push_back(std::move(row));
}

void RiderPanel::render(const RenderContext* ctx) {

  const RiderSnapshot* snap = ctx->get_snapshot(rider_uid);
  if (!snap)
    return;

  std::string title_text = snap->name;

  if (title != title_text) {
    title = title_text;
    if (title_tex)
      SDL_DestroyTexture(title_tex);
    SDL_Surface* s =
        TTF_RenderText_Blended(font, title.c_str(), 0, {255, 255, 255});
    title_tex = SDL_CreateTextureFromSurface(ctx->renderer, s);
    SDL_DestroySurface(s);
  }
  // Draw Title
  if (!title_tex) {
    SDL_Surface* s = TTF_RenderText_Blended(font, title.c_str(), 0,
                                            {255, 255, 0, 255}); // Yellow title
    title_tex = SDL_CreateTextureFromSurface(ctx->renderer, s);
    SDL_DestroySurface(s);
  }

  float w, h;
  SDL_GetTextureSize(title_tex, &w, &h);
  SDL_FRect r = {(float)x, (float)y, w, h};
  SDL_RenderTexture(ctx->renderer, title_tex, nullptr, &r);

  // HACK for now: Iterate rows, find their internal fields, and update their
  // ID? Proper way: Refactor ValueField::render to take a snapshot, not look
  // it up itself. Draw all rows
  for (auto& row : rows) {
    row->render_for_rider(ctx, snap);
  }
}

void RiderPanel::render_imgui(const RenderContext* ctx) {
  if (!visible || rider_uid == -1)
    return;

  const RiderSnapshot* snap = ctx->get_snapshot(rider_uid);

  // compute where the plot goes based on panel position
  ImVec2 pos((float)x, (float)y + 140);
  ImVec2 size(300, 300);

  ImGui::SetNextWindowPos(pos, ImGuiCond_Always);
  ImGui::SetNextWindowSize(size, ImGuiCond_Always);

  ImGuiWindowFlags win_flags =
      ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoMove |
      ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoFocusOnAppearing |
      ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoBackground;

  static double data1[static_cast<size_t>(PowerTerm::COUNT)];
  for (size_t i = 0; i < static_cast<size_t>(PowerTerm::COUNT); ++i) {
    data1[i] = static_cast<float>(snap->power_breakdown[i]);
  }
  // clamp so we don't show negative inertia term
  // thought ideally we'd only show the output of the other terms
  // but that'd require subtracting the change from before or sth similar?
  data1[static_cast<size_t>(PowerTerm::Inertia)] =
      std::max(0.0, data1[static_cast<size_t>(PowerTerm::Inertia)]);
  static ImPlotPieChartFlags flags = 0;
  bool open = ImGui::Begin("##riderplot", nullptr, win_flags);

  // DragFloat controls
  // ImGui::SetNextItemWidth(250);
  // for (size_t i = 0; i < static_cast<size_t>(PowerTerm::COUNT); ++i) {
  //   char label[32];
  //   snprintf(label, sizeof(label), POWER_LABELS[i], i);
  //   ImGui::DragFloat(label, &data1[i], 0.01f, 0, 1);
  // }

  if (open) {
    if (ImGui::Button(show_plot ? "Hide plot" : "Show plot")) {
      show_plot = !show_plot;
    }

    if (show_plot) {
      if (ImPlot::BeginPlot("##Pie1",
                            ImVec2(ImGui::GetTextLineHeight() * 16,
                                   ImGui::GetTextLineHeight() * 16),
                            ImPlotFlags_Equal | ImPlotFlags_NoMouseText)) {
        ImPlot::SetupAxes(nullptr, nullptr, ImPlotAxisFlags_NoDecorations,
                          ImPlotAxisFlags_NoDecorations);
        ImPlot::SetupAxesLimits(0, 1, 0, 1);
        ImPlot::PlotPieChart(POWER_LABELS, data1,
                             static_cast<int>(PowerTerm::COUNT), 0.5, 0.5, 0.4,
                             "%.2f", 90, flags);
        ImPlot::EndPlot();
      }
    }
  }

  ImGui::End();
}

bool BaseEditableField::handle_event(const SDL_Event* e) {
  switch (e->type) {

  // ================================
  // CLICK EVENTS
  // ================================
  case SDL_EVENT_MOUSE_BUTTON_DOWN: {
    int mx = e->button.x;
    int my = e->button.y;
    bool inside = (mx >= x && mx <= x + w && my >= y && my <= y + h);

    if (inside) {
      editing = true;
      buffer = current_text;
      SDL_StartTextInput(window);
      last_cursor_blink = SDL_GetTicks();
      cursor_visible = true;
      return true;
    } else if (editing) {
      commit();
      return true;
    }
    break;
  }

  // ================================
  // KEY EVENTS
  // ================================
  case SDL_EVENT_KEY_DOWN:
    if (!editing)
      break;

    if (e->key.key == SDLK_BACKSPACE) {
      if (!buffer.empty())
        buffer.pop_back();
      return true;
    }

    if (e->key.key == SDLK_RETURN || e->key.key == SDLK_KP_ENTER) {
      commit();
      return true;
    }

    break;

  // ================================
  // TEXT INPUT (UTF-8)
  // ================================
  case SDL_EVENT_TEXT_INPUT:
    if (!editing)
      break;

    for (char c : std::string(e->text.text)) {
      if (accept_char(c, buffer))
        buffer.push_back(c);
      SDL_Log("%s", buffer.c_str());
    }
    return true;
  }

  return false;
}

void BaseEditableField::render(const RenderContext* ctx) {
  if (editing) {
    Uint32 now = SDL_GetTicks();
    if (now - last_cursor_blink >= BLINK_MS) {
      cursor_visible = !cursor_visible;
      last_cursor_blink = now;
    }
  }

  SDL_Renderer* renderer = ctx->renderer;

  // if (!bg_texture)
  //   create_bg(renderer);

  std::string saved = current_text;
  ValueField::set_text(current_display_text());

  ValueField::render(ctx);

  current_text = saved;
  //
  // // regenerate texture every frame while editing
  // if (texture) {
  //   SDL_DestroyTexture(texture);
  //   texture = nullptr;
  // }
  // if (!displayed.empty()) {
  //   SDL_Surface* surf =
  //       TTF_RenderText_Blended(font, displayed.c_str(), 0, text_color);
  //   texture = SDL_CreateTextureFromSurface(renderer, surf);
  //   SDL_DestroySurface(surf);
  // }
  //
  // SDL_FRect rect{(float)x, (float)y, (float)w, (float)h};
  // SDL_RenderTexture(renderer, bg_texture, nullptr, &rect);
  //
  // if (texture) {
  //   float tw, th;
  //   SDL_GetTextureSize(texture, &tw, &th);
  //   SDL_FRect dst{(float)x, (float)y, tw, th};
  //   SDL_RenderTexture(renderer, texture, nullptr, &dst);
  // }
}

void BaseEditableField::commit() {
  editing = false;
  SDL_StopTextInput(window);
  set_text(buffer);
  if (on_commit)
    on_commit(buffer);
}

std::string BaseEditableField::current_display_text() const {
  if (!editing)
    return current_text;

  if (cursor_visible)
    return buffer + "|";

  return buffer;
}

bool EditableNumberField::accept_char(char c, const std::string& before) {
  if (c >= '0' && c <= '9')
    return true;
  if (c == '.' && before.find('.') == std::string::npos)
    return true;
  if (c == '-' && before.empty())
    return true;
  return false;
}
```

