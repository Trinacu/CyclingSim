include/appstate.h
```
// include/appstate.h
#ifndef APPSTATE_H
#define APPSTATE_H

#include "sim.h"
#include "texturemanager.h" // For GameResources
#include <SDL3/SDL.h>
#include <chrono>
#include <thread>

// Forward declarations
class IScreen;
enum class ScreenType;

class AppState {
public:
  // Constants
  const int SCREEN_WIDTH = 1000;
  const int SCREEN_HEIGHT = 640;

  const int FPS = 60;

  // Core Hardware/SDL Resources (Owned by AppState)
  SDL_Window* window = nullptr;
  SDL_Renderer* renderer = nullptr;

  std::chrono::steady_clock::time_point last_frame_time;

  // Logic & Assets (Owned by AppState)
  GameResources* resources = nullptr;
  Course* course = nullptr;
  Simulation* sim = nullptr;
  std::thread* physics_thread = nullptr;

  // View State
  IScreen* current_screen_ptr = nullptr; // Renamed to avoid confusion
  ScreenType current_type;

  AppState();
  ~AppState();

  void switch_screen(ScreenType type);

  bool load_image(const char* id, const char* filename);

  // Helper to get window size dynamically if needed
  Vector2d get_window_size() const {
    return Vector2d(SCREEN_WIDTH, SCREEN_HEIGHT);
  }
};

#endif
```

include/camera.h
```
#ifndef CAMERA_H
#define CAMERA_H

#include "course.h"
#include "snapshot.h"
#include <optional>

class Camera {
public:
  Camera(const Course* course, int world_width, Vector2d screensize);

  // --- Transformations ---
  Vector2d world_to_screen(Vector2d world) const;
  MatrixX2d world_to_screen(MatrixX2d world) const;
  Vector2d screen_to_world(Vector2d screen) const;

  // --- Follow logic ---
  void set_target_id(int rider_uid);
  void clear_target();
  bool has_target() const { return target_uid.has_value(); }

  // Update camera position each frame
  void update(const SnapshotMap& snaps);

  // --- Manual controls ---
  void pan(double dx, double dy); // screen space delta
  void zoom(double amount);       // amount > 0 zooms in

  // Direct set (used rarely)
  void set_center(Vector2d p) { pos = p; }

  // Accessors
  Vector2d get_pos() const { return pos; }

private:
  const Course* course;
  const int world_width;
  Vector2d screensize;

  double scale;      // horizontal world→screen scale
  double vert_scale; // vertical world→screen scale

  Vector2d pos; // world coordinate camera center
  std::optional<int> target_uid;

  // smooth follow parameters
  double follow_strength = 0.15; // 0=no follow, 1=teleport
};

#endif
```

include/corerenderer.h
```
#ifndef CORE_RENDERER_H
#define CORE_RENDERER_H

#include "display.h"
#include "texturemanager.h"
#include <SDL3/SDL.h>
#include <memory>
#include <vector>

// The fundamental UI-only renderer.
// This draws only 2D/UI Drawables; no camera, no simulation, no world-space.
class CoreRenderer {
public:
  CoreRenderer(SDL_Renderer* renderer, GameResources* resources);
  virtual ~CoreRenderer() = default;

  // Add/remove UI drawables
  void add_drawable(std::unique_ptr<Drawable> d);
  void clear_drawables();

  // The main render entry point (screens call this)
  virtual void render_frame();

  SDL_Renderer* sdl() const { return renderer; }
  GameResources* get_resources() const { return resources; }

protected:
  SDL_Renderer* renderer;   // Raw pointer; owned by AppState
  GameResources* resources; // Raw pointer; owned by AppState
  std::vector<std::unique_ptr<Drawable>> drawables;
};

#endif
```

include/course.h
```
// course.h
#ifndef COURSE_H
#define COURSE_H

#include "pch.hpp"

struct Wind {
  double speed;
  double heading;
};

struct Segment {
  double start_x;
  double length;
  double slope;
  double end_x;
  double heading;

  double altitude_at(double x) const { return slope * (x - start_x); }
};

std::ostream& operator<<(std::ostream& os, const Segment& seg);

class ICourseView {
public:
  virtual double get_slope(double pos) const = 0;
  virtual double get_altitude(double pos) const = 0;
  virtual Wind get_wind(double pos) const = 0;
  // virtual bool isCheckpoint(double pos) const = 0;
  virtual ~ICourseView() = default;
};

class Course : public ICourseView {
private:
  std::vector<Segment> segments;
  std::vector<double> altitudes; // y at each segment start

public:
  double total_length;

  std::vector<Vector2d> visual_points;

  Course(const std::vector<std::array<double, 3>> segments);
  static Course
  from_segments(const std::vector<std::array<double, 3>> segments);

  double get_altitude(double pos) const override;
  double get_slope(double pos) const override;
  Wind get_wind(double pos) const override;

  int find_segment(double pos) const;

  MatrixX2d get_points(double x_min, double x_max) const;

  static Course create_flat();
  static Course create_endulating();

  void print();
};
#endif
```

include/display.h
```
// display.h
#ifndef DISPLAY_H
#define DISPLAY_H

#include "camera.h"
#include "course.h"
#include "texturemanager.h"
#include <memory>

#include <SDL3/SDL.h>

struct RenderContext {
  SDL_Renderer* renderer;
  std::weak_ptr<Camera> camera_weak;
  const SnapshotMap* rider_snapshots;
  ResourceProvider* resources;

  const RiderSnapshot* get_snapshot(const size_t id) const {
    auto it = rider_snapshots->find(id);
    if (it != rider_snapshots->end())
      return &it->second;
    return nullptr;
  }
};

enum class RenderLayer : int { Course = 0, Riders = 1, UI = 2, COUNT };

class Drawable {
public:
  virtual RenderLayer layer() const = 0;
  // Called each frame; the implementer draws itself with the given SDL_Renderer
  virtual void render(const RenderContext* ctx) = 0;
  virtual bool handle_event(const SDL_Event* e) { return false; }
  virtual ~Drawable() = default;
};

class CourseDrawable : public Drawable {
private:
  const Course* course;

public:
  CourseDrawable(const Course* course_);
  RenderLayer layer() const override { return RenderLayer::Course; }

  void render(const RenderContext* ctx) override;
};

class RiderDrawable : public Drawable {
public:
  RiderDrawable() = default;
  RenderLayer layer() const override { return RenderLayer::Riders; }

  void render(const RenderContext* ctx) override;
};

#endif
```

include/helpers.h
```
struct SDL_Surface;
struct SDL_Texture;
struct SDL_Renderer;

void convert_color(SDL_Surface* surf);

SDL_Surface* load_transparent_bmp(const char* filename);
SDL_Texture* load_from_file(SDL_Renderer* renderer, const char* filename);
```

include/mytypes.h
```
```

include/pch.hpp
```
// pch.hpp
#ifndef PCH_HPP
#define PCH_HPP

#include <Eigen/Core> // Minimal Eigen header
#include <cmath>
#include <iostream>
#include <vector>
// Add other common headers here
//
using Vector2d = Eigen::RowVector2d;
using MatrixX2d = Eigen::MatrixX2d;
using MatrixX3d = Eigen::MatrixX3d;

#endif // PCH_HPP
```

include/rider.h
```
// rider.h
#ifndef RIDER_H
#define RIDER_H

#include "course.h"
#include "snapshot.h"
#include "texturemanager.h"
#include <SDL3/SDL.h>
#include <iostream>

struct SDL_Texture;

class Team {
private:
public:
  std::string name;
  Team(const char* name_);

  int id;
};

// struct RiderSnapshot {
//   const size_t uid;
//   std::string name;
//   double pos;
//   double slope;
//   Vector2d pos2d;
//   double power;
//   double effort;
//   double speed;
//   double km_h;
//   double heading;
//   Team team;
// };
//
class Bike {
public:
  double mass;
  double wheel_i;
  double wheel_r;
  double wheel_drag_factor;
  double crr;
  double dt_loss;

  Bike(double mass_, double wheel_i_, double wheel_r_,
       double wheel_drag_factor_, double crr_, double dt_loss_);
  static Bike create_generic();
};

class Rider {
private:
  static size_t global_id_counter; // declaration
  const size_t uid;                // unique ID
  double ftp_base;
  double effort;
  double cda;
  double cda_factor;
  double effective_cda;
  double mass;
  double total_mass;
  double heading = 0;
  double v_hw;
  Vector2d _pos2d = Vector2d{0, 0};

  double power;

  double drag_coeff;
  double roll_coeff;
  double inertia_coeff;
  double f_grav;
  double slope;
  double mass_ir;

  double timestep;

  Bike bike;
  Team team;
  TextureManager* tex_manager;
  const ICourseView* course;

  void set_cda_factor(double cda_factor_);
  void set_mass(double total_mass_);

public:
  std::string name;
  double target_effort;
  double pos = 0.0;
  double altitude = 0.0;
  double speed;
  const SDL_Texture* image;

  Rider(std::string name_, double ftp_base_, double mass_, double cda_,
        Bike bike_, Team team_);
  static Rider* create_generic(Team team_);

  void set_course(const ICourseView* cv);

  RiderSnapshot snapshot() const;

  void change_bike(Bike bike_);

  void reset();
  void update(double dt);

  size_t get_id() const { return uid; }

  double km() const;
  double km_h() const;

  Vector2d get_pos2d() const;
  void set_pos2d(Vector2d pos);

  double pow_speed(double new_speed) const;
  double pow_speed_prime(double new_speed);
  double pow_speed_double_prime(double new_speed);

  void compute_drag();
  void compute_roll();
  void compute_inertia();
  void compute_coeff();
  void compute_headwind();

  double newton(double power, double speed_guess, int max_iterations = 20);
  double householder(double power, double speed_guess, int max_iterations = 20);

  // friend allows aceesing private/protected members
  friend std::ostream& operator<<(std::ostream& os, const Rider& r);
};

#endif
```

include/screen.h
```
// screen.h
#ifndef SCREEN_H
#define SCREEN_H

#include "SDL3/SDL_events.h"
#include "appstate.h"
#include "simulationrenderer.h"
#include "widget.h"

enum class ScreenType { Menu, Simulation, Result };

class IScreen {
public:
  virtual ~IScreen() {}
  virtual void update() = 0;
  virtual void render() = 0;

  // virtual void handle_event(SDL_Event* e) = 0;
  virtual bool handle_event(const SDL_Event* e) {
    if (e->type == SDL_EVENT_KEY_DOWN) {
      if (e->key.key == SDLK_RETURN) {
        // start simulation
        // state->switch_screen(ScreenType::Simulation);
        return true;
      }
    }
    return false;
  }
};

class MenuScreen : public IScreen {
public:
  AppState* state;

  MenuScreen(AppState* s) : state(s) {}

  void update() override {}
  void render() override;
};

class ResultsScreen : public IScreen {
public:
  AppState* state;
  ResultsScreen(AppState* s) : state(s) {}

  void update() override {};

  void render() override;
};

class SimulationScreen : public IScreen {
public:
  // DisplayEngine* display = nullptr;
  int WORLD_WIDTH = 200;

  SimulationScreen(AppState* s);
  ~SimulationScreen() {} // delete sim_renderer; }

  void update() override;
  void render() override;

  bool handle_event(const SDL_Event* e) override;

private:
  AppState* state;
  std::unique_ptr<SimulationRenderer> sim_renderer;

  int selected_rider_uid = 0;

  // Camera interaction state
  bool dragging = false;
  int drag_start_x = 0;
  int drag_start_y = 0;

  RiderPanel* rider_panel = nullptr;
};

#endif
```

include/sim.h
```
// sim.h
#ifndef SIM_H
#define SIM_H

#include "course.h"
#include "rider.h"
#include <mutex>

#include <atomic>

class PhysicsEngine {
private:
  const Course* course;
  mutable std::mutex frame_mtx;
  std::vector<Rider*> riders;

public:
  explicit PhysicsEngine(const Course* c);
  void add_rider(Rider* r);
  void update(double dt);

  const Course* get_course() const { return course; }
  double get_course_length() const { return course->total_length; }

  // do these returns need to/should be const?
  const std::vector<Rider*>& get_riders() const;
  const Rider* get_rider(int idx) const;
  std::mutex* get_frame_mutex() const;

  ~PhysicsEngine();
};

// forward declare
class SimulationCondition;

// Your main simulation loop (runs in its own thread or fixed-step driver)
class Simulation {
private:
  PhysicsEngine engine;
  std::atomic<bool> running{false};
  double time_factor = 1.0;
  double sim_seconds = 0.0;

  const float dt = 0.1; // 100 Hz physics

  void step_fixed(double dt);

public:
  Simulation(const Course* c);

  void start_realtime();

  void run_max_speed(const SimulationCondition& cond);

  void stop();

  double get_time_factor() { return time_factor; }
  void set_time_factor(double f) { time_factor = f; }

  const double get_sim_seconds() const;
  const PhysicsEngine* get_engine() const;
  PhysicsEngine* get_engine();

  std::atomic<bool> physics_error{false};
  std::string physics_error_message;
};

class SimulationCondition {
public:
  virtual ~SimulationCondition() = default;
  virtual bool is_met(const Simulation& sim) const = 0;
};

#endif
```

include/simulationrenderer.h
```
#ifndef SIMULATION_RENDERER_H
#define SIMULATION_RENDERER_H

#include "corerenderer.h"
#include "display.h"
#include "sim.h"
#include "widget.h"
#include <memory>

// This renderer extends CoreRenderer with:
// - Camera
// - World-to-screen transform
// - Automatic SnapshotMap generation
// - Course + Rider drawing
class SimulationRenderer : public CoreRenderer {
public:
  SimulationRenderer(SDL_Renderer* r, GameResources* resources, Simulation* sim,
                     std::shared_ptr<Camera> camera);

  ~SimulationRenderer() override = default;

  // Main render function: adds simulation info + world drawables.
  void render_frame() override;
  void update();

  RiderPanel* get_rider_panel() const { return rider_panel; }
  void set_rider_panel(RiderPanel* p) { rider_panel = p; }

  // World drawables
  void add_world_drawable(std::unique_ptr<Drawable> d);

  std::shared_ptr<Camera> get_camera() const { return camera; }

  int pick_rider(double screen_x, double screen_y) const;

  const SnapshotMap& get_snapshot_map() const { return snapshot_front; }
  void build_and_swap_snapshots();

  bool handle_event(const SDL_Event* e);

private:
  Simulation* sim;                // Not owned
  std::shared_ptr<Camera> camera; // Owned here
  std::vector<std::unique_ptr<Drawable>> world_drawables;

  RiderPanel* rider_panel = nullptr;

  // Double buffers
  SnapshotMap snapshot_front; // used by render + UI
  SnapshotMap snapshot_back;  // temporary build buffer
  mutable std::mutex snapshot_swap_mtx;
};

#endif
```

include/snapshot.h
```
#ifndef SNAPSHOT_H
#define SNAPSHOT_H

#include "pch.hpp"
#include <string>
#include <unordered_map>

struct RiderSnapshot {
  const size_t uid;
  std::string name;
  double pos;
  double slope;
  Vector2d pos2d;
  double power;
  double effort;
  double speed;
  double km_h;
  double heading;
  int team_id;
};

using SnapshotMap = std::unordered_map<int, RiderSnapshot>;

#endif
```

include/texturemanager.h
```
// texturemanager.h
#ifndef TEXTUREMANAGER_H
#define TEXTUREMANAGER_H

#include "SDL3/SDL_log.h"
#include <string>
#include <unordered_map>

struct SDL_Renderer;
struct SDL_Texture;
struct TTF_Font;

class TextureManager {
public:
  // You must give TextureManager a valid SDL_Renderer* at construction time.
  // It keeps that renderer internally so it can turn surfaces → textures.
  TextureManager(SDL_Renderer* renderer_);

  ~TextureManager();

  // Non‐copyable / non‐movable for simplicity
  TextureManager(const TextureManager&) = delete;
  TextureManager& operator=(const TextureManager&) = delete;

  bool load_texture(const char* id, const char* file_path);
  SDL_Texture* get_texture(const char* id) const;

  // (Optional) Query width/height of a loaded texture.
  bool query_texture(const char* id, float& outW, float& outH) const;

private:
  SDL_Renderer* renderer;
  std::unordered_map<std::string, SDL_Texture*> texture_map;
};

class FontManager {
public:
  FontManager() {};

  ~FontManager();

  // Non‐copyable / non‐movable for simplicity
  FontManager(const FontManager&) = delete;
  FontManager& operator=(const FontManager&) = delete;

  bool load_font(const char* id, const char* file_path, int font_size);
  TTF_Font* get_font(const char* id) const;

private:
  std::unordered_map<std::string, TTF_Font*> font_map;
};

class ResourceProvider {
public:
  virtual TextureManager* get_textureManager() = 0;
  virtual FontManager* get_fontManager() = 0;
  virtual ~ResourceProvider() = default;
};

class GameResources : public ResourceProvider {
public:
  GameResources(SDL_Renderer* renderer_)
      : renderer(renderer_), textureManager(renderer_) {
    load_common_resources();
  }

  TextureManager* get_textureManager() override { return &textureManager; }
  FontManager* get_fontManager() override { return &fontManager; }

  void load_common_resources() {
    if (!textureManager.load_texture("player", "resources/collated_grid.png")) {
      SDL_Log("Failed to load 'player' texture");
    }
    if (!fontManager.load_font("default", "resources/Roboto-Regular.ttf", 16)) {
      SDL_Log("Failed to load 'default' font");
    }
    if (!fontManager.load_font("stopwatch",
                               "resources/DSEG7Classic-Regular.ttf", 32)) {
      SDL_Log("Failed to load 'stopwatch' font");
    }
  }

private:
  SDL_Renderer* renderer;
  TextureManager textureManager;
  FontManager fontManager;
};

#endif
```

include/widget.h
```
// widget.h
#ifndef WIDGET_H
#define WIDGET_H

#include "display.h"
#include "sim.h"
#include <SDL3/SDL.h>
#include <SDL3_ttf/SDL_ttf.h>

std::string format_number(double value, int precision = 1);

class Widget : public Drawable {
public:
  RenderLayer layer() const override { return RenderLayer::UI; }
  virtual void render(const RenderContext* ctx) override = 0;
  virtual ~Widget() = default;
};

class Stopwatch : public Widget {
private:
  Simulation* sim;
  TTF_Font* font;
  SDL_Color text_color = SDL_Color{80, 255, 40, 255};
  int screen_x, screen_y;
  int width = 0, height = 0; // Texture dimensions
  int bg_width = 0, bg_height = 0;
  int update_interval_ms;
  char text[16];

  SDL_Texture* texture = nullptr;
  SDL_Texture* bg_texture = nullptr;

  int padding = 6;
  int edge_thickness = 3;
  int content_offset = padding + edge_thickness;

  uint32_t last_update_ticks = 0;

  SDL_Texture* render_time(SDL_Renderer* renderer, const char* s, int& out_w,
                           int& out_h);
  SDL_Texture* create_base(SDL_Renderer* renderer);

public:
  Stopwatch(int x, int y, TTF_Font* font_, Simulation* sim_,
            int update_ms = 100)
      : screen_x(x), screen_y(y), font(font_), sim(sim_),
        update_interval_ms(update_ms) {
    last_update_ticks = 0;
  }

  ~Stopwatch() {
    if (texture)
      SDL_DestroyTexture(texture);
    if (bg_texture)
      SDL_DestroyTexture(bg_texture);
  }

  void update_texture(const RenderContext* ctx);
  void render(const RenderContext* ctx) override;
};

class TimeFactorButton : public Widget {
private:
  int x, y, w, h;
  double value;
  Simulation* sim;
  TTF_Font* font;

public:
  TimeFactorButton(int x_, int y_, int h_, double val, Simulation* sim_,
                   TTF_Font* f)
      : x(x_), y(y_), w(50), h(h_), value(val), sim(sim_), font(f) {}

  void render(const RenderContext* ctx) override;

  bool handle_event(const SDL_Event* e) override;
};

class TimeFactorSlider : public Widget {
private:
  int x, y, w, h;
  double neutral_point = 0.3; // where factor = 1.0
  int marker_width = 4;
  bool dragging = false;
  double slider_pos = 0.5; // slider position 0..1
  Simulation* sim;

public:
  TimeFactorSlider(int x_, int y_, int w_, int h_, Simulation* sim_)
      : x(x_), y(y_), w(w_), h(h_), sim(sim_) {}

  void render(const RenderContext* ctx) override;
  bool handle_event(const SDL_Event* e) override;

private:
  double slider_to_factor(double t);
  double factor_to_slider(double f);
};

class TimeControlPanel : public Widget {
private:
  int x, y, h;
  int slider_w = 200;
  std::vector<std::unique_ptr<Widget>> children;

public:
  TimeControlPanel(int x_, int y_, int h_, TTF_Font* font, Simulation* sim);

  void render(const RenderContext* ctx) override;
  bool handle_event(const SDL_Event* e) override;
};

class ValueField {
public:
  using DataGetter = std::function<std::string(const RiderSnapshot&)>;

private:
  TTF_Font* font;
  SDL_Color text_color = {255, 255, 255, 255};
  int x, y, width, height;

  // Logic
  size_t target_rider_id;
  DataGetter getter;

  // Caching
  std::string current_text;
  SDL_Texture* texture = nullptr;
  SDL_Texture* bg_texture = nullptr;
  uint32_t last_update = 0;

  void update_texture(SDL_Renderer* renderer, const RiderSnapshot& snap);
  void create_bg(SDL_Renderer* renderer);

public:
  ValueField(int x, int y, int w, int h, TTF_Font* font, size_t id,
             DataGetter getter);
  ~ValueField();

  // void render(const RenderContext* ctx) override;
  void render_with_snapshot(const RenderContext* ctx,
                            const RiderSnapshot* snap);

  // Allow parents to move this widget
  void set_position(int new_x, int new_y) {
    x = new_x;
    y = new_y;
  }
  int get_width() const { return width; }
};

class MetricRow {
private:
  std::string label_txt;
  std::string unit_txt;
  TTF_Font* font;

  // Components
  std::unique_ptr<ValueField> field;
  SDL_Texture* label_tex = nullptr;
  SDL_Texture* unit_tex = nullptr;

  int x, y;
  int label_width = 80; // Fixed width so boxes align vertically
  int padding = 10;

public:
  MetricRow(int x, int y, TTF_Font* font, size_t id, std::string label,
            std::string unit, ValueField::DataGetter getter);

  ~MetricRow();

  // void render(const RenderContext* ctx) override;
  void render_for_rider(const RenderContext* ctx, const RiderSnapshot* snap);

  // Helper to calculate total height for the panel
  int get_height() const { return 30; } // simplified
  void set_position(int new_x, int new_y);
};

class RiderPanel : public Widget {
private:
  int x, y;
  int rider_uid = 0;
  TTF_Font* font;

  std::string title;
  SDL_Texture* title_tex = nullptr;

  // All the rows
  std::vector<std::unique_ptr<MetricRow>> rows;

public:
  RiderPanel(int x, int y, TTF_Font* font);
  ~RiderPanel();

  void set_rider_id(int uid);
  // Usage: panel->add_row("Speed", "km/h", [](auto s){ return ... });
  void add_row(std::string label, std::string unit,
               ValueField::DataGetter getter);

  void render(const RenderContext* ctx) override;
};

#endif
```

src/appstate.cpp
```
// src/appstate.cpp
#include "appstate.h"
#include "SDL3_ttf/SDL_ttf.h"
#include "screen.h"

AppState::AppState() {
  // 1. Initialize SDL Core
  if (!SDL_Init(SDL_INIT_VIDEO)) {
    SDL_Log("Couldn't initialize SDL: %s", SDL_GetError());
    throw std::runtime_error("SDL Init Failed");
  }
  if (!TTF_Init()) {
    SDL_Log("Couldn't initialize TTF: %s", SDL_GetError());
    throw std::runtime_error("TTF Init Failed");
  }

  // 2. Create Window and Renderer ONCE
  if (!SDL_CreateWindowAndRenderer("Cycle Sim", SCREEN_WIDTH, SCREEN_HEIGHT, 0,
                                   &window, &renderer)) {
    SDL_Log("CreateWindowAndRenderer failed: %s", SDL_GetError());
    throw std::runtime_error("Window Creation Failed");
  }

  // 3. Initialize Shared Resources
  resources = new GameResources(renderer);

  // 4. Initialize Simulation
  course = new Course(Course::create_endulating());
  sim = new Simulation(course); // Sim now owns the course
  sim->set_time_factor(5.0);

  // (Optional) Setup default riders here or in Main
}

AppState::~AppState() {
  // Cleanup in reverse order of creation
  if (physics_thread) {
    sim->stop();
    physics_thread->join();
    delete physics_thread;
  }

  if (current_screen_ptr)
    delete current_screen_ptr;
  if (sim)
    delete sim;
  if (course)
    delete course;
  if (resources)
    delete resources;

  if (renderer)
    SDL_DestroyRenderer(renderer);
  if (window)
    SDL_DestroyWindow(window);

  TTF_Quit();
  SDL_Quit();
}

bool AppState::load_image(const char* id, const char* filename) {
  return resources->get_textureManager()->load_texture(id, filename);
}

void AppState::switch_screen(ScreenType type) {
  if (current_screen_ptr) {
    delete current_screen_ptr;
    current_screen_ptr = nullptr;
  }

  current_type = type;

  switch (type) {
  case ScreenType::Menu:
    current_screen_ptr = new MenuScreen(this);
    break;
  case ScreenType::Simulation:
    current_screen_ptr = new SimulationScreen(this);
    break;
  case ScreenType::Result:
    current_screen_ptr = new ResultsScreen(this);
    break;
  }
}
```

src/camera.cpp
```
#include "camera.h"
#include "pch.hpp"

Camera::Camera(const Course* course_, int world_width_, Vector2d screensize_)
    : course(course_), world_width(world_width_), screensize(screensize_),
      scale(screensize_.x() / (double)world_width_), vert_scale(1.0),
      pos(0.0, 0.0) {
  target_uid = 0;
}

// ------------------------
// FOLLOWING LOGIC
// ------------------------
void Camera::set_target_id(int rider_uid) { target_uid = rider_uid; }

void Camera::clear_target() { target_uid.reset(); }

void Camera::update(const SnapshotMap& snaps) {
  if (!target_uid.has_value())
    return;

  int id = *target_uid;
  auto it = snaps.find(id);
  if (it == snaps.end())
    return;

  const RiderSnapshot& snap = it->second;

  // Target position is rider position
  Vector2d target_pos = snap.pos2d;

  // Follow altitude using course
  target_pos.y() = course->get_altitude(target_pos.x());

  // Smooth interpolation toward target
  pos = pos + follow_strength * (target_pos - pos);
}

// ------------------------
// MANUAL CAMERA CONTROLS
// ------------------------
void Camera::pan(double dx, double dy) {
  // User panning breaks following
  clear_target();

  // convert screen dx to world dx
  Vector2d delta(dx / scale, dy / (-vert_scale));

  pos += delta;
}

void Camera::zoom(double amount) {
  // Simple zoom factor
  double factor = 1.0 + amount;

  scale *= factor;
  if (scale < 0.01)
    scale = 0.01;
  if (scale > 5.0)
    scale = 5.0;
}

// ------------------------
// TRANSFORMS
// ------------------------
Vector2d Camera::world_to_screen(Vector2d world) const {
  return ((world - pos) * scale).cwiseProduct(Vector2d(1, -vert_scale)) +
         screensize * 0.5;
}

MatrixX2d Camera::world_to_screen(MatrixX2d w) const {
  MatrixX2d r = w;

  r.rowwise() -= pos;
  r *= scale;
  r.col(1) *= -vert_scale;
  r.rowwise() += screensize * 0.5;

  return r;
}

Vector2d Camera::screen_to_world(Vector2d s) const {
  Vector2d centered = s - screensize * 0.5;

  Vector2d scaled;
  scaled.x() = centered.x() / scale;
  scaled.y() = centered.y() / (-vert_scale);

  return scaled + pos;
}
```

src/corerenderer.cpp
```
#include "corerenderer.h"
#include <memory>

CoreRenderer::CoreRenderer(SDL_Renderer* r, GameResources* res)
    : renderer(r), resources(res) {}

void CoreRenderer::add_drawable(std::unique_ptr<Drawable> d) {
  drawables.push_back(std::move(d));
}

void CoreRenderer::clear_drawables() { drawables.clear(); }

void CoreRenderer::render_frame() {
  // No camera, no simulation, no snapshot logic.
  // Only UI drawables.

  SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
  SDL_RenderClear(renderer);

  RenderContext ctx;
  ctx.renderer = renderer;
  ctx.resources = resources;
  ctx.camera_weak = std::weak_ptr<Camera>();
  ctx.rider_snapshots = nullptr; // Not used

  for (auto& d : drawables) {
    d->render(&ctx);
  }

  SDL_RenderPresent(renderer);
}
```

src/course.cpp
```
#include "course.h"
#include "SDL3/SDL_log.h"
#include "pch.hpp"
#include <stdexcept>

// make CourseSegment easier to print
std::ostream& operator<<(std::ostream& os, const Segment& cs) {
  os << cs.length << " m at " << cs.slope * 100 << "%";
  return os;
}

Course::Course(const std::vector<std::array<double, 3>> segments_) {
  double x = 0.0, y = 0.0;
  visual_points.push_back(Vector2d(x, y));

  for (auto [len, slope, heading] : segments_) {
    segments.push_back({x, len, slope, x + len, heading});
    altitudes.push_back(y);

    x += len;
    y += len * slope;
    visual_points.push_back(Vector2d(x, y));
  }
  total_length = x;
  SDL_Log("%f", total_length);
}

Course
Course::from_segments(const std::vector<std::array<double, 3>> segments) {
  return Course(segments);
}

Course Course::create_flat() {
  std::vector<std::array<double, 3>> v = {{300000, 0, 0}};
  return Course(v);
}

Course Course::create_endulating() {
  std::vector<std::array<double, 3>> v = {
      {100, 0, 0}, {200, 0.1, 0}, {200, 0, 0}, {500, 0.05, 0}};
  return Course(v);
}

double Course::get_altitude(double pos) const {
  int idx = find_segment(pos);
  return altitudes[idx] + segments[idx].altitude_at(pos);
}

double Course::get_slope(double pos) const {
  return segments[find_segment(pos)].slope;
}

Wind Course::get_wind(double pos) const { return Wind{1, 0}; }

MatrixX2d Course::get_points(double x_min, double x_max) const {
  if (x_min > x_max)
    std::swap(x_min, x_max);
  if (x_min < 0)
    x_min = 0;
  int i0 = find_segment(x_min);
  int i1 = find_segment(x_max);

  // count points: endpoints + internal breaks
  int count = 2; // for x_min and x_max
  for (int i = i0 + 1; i <= i1; ++i) {
    double bx = segments[i].start_x;
    if (bx > x_min && bx < x_max)
      ++count;
  }

  MatrixX2d pts(count, 2);
  int row = 0;
  // x_min
  pts(row, 0) = x_min;
  pts(row, 1) = get_altitude(x_min);
  ++row;

  // internal breaks
  for (int i = i0 + 1; i <= i1; ++i) {
    double bx = segments[i].start_x;
    if (bx > x_min && bx < x_max) {
      pts(row, 0) = bx;
      pts(row, 1) = altitudes[i];
      ++row;
    }
  }

  // x_max
  pts(row, 0) = x_max;
  pts(row, 1) = get_altitude(x_max);
  return pts;
}

int Course::find_segment(double x) const {
  if (x > total_length) {
    SDL_Log("Trying to find segment for x > total_length (%.1f > %f.1f) in "
            "Course::find segment()",
            x, total_length);
    return segments.size() - 1;
  }
  int lo = 0, hi = segments.size() - 1;
  while (lo <= hi) {
    int mid = (lo + hi) / 2;
    if (x < segments[mid].start_x)
      hi = mid - 1;
    else if (x >= segments[mid].end_x)
      lo = mid + 1;
    else
      return mid;
  }
  throw std::out_of_range("x out of course bounds");
}

void Course::print() {
  std::cout << "Course:" << std::endl;
  for (const Segment& course_segment : segments) {
    std::cout << course_segment << std::endl;
  }
  for (int i = 0; i < segments.size(); i++) {
    std::cout << segments[i].start_x << ", " << altitudes[i] << std::endl;
  }
  // for (const std::array<double, 3> &seg_range : segment_ranges) {
  //   std::cout << "x_start: " << seg_range[0] << ",\tx_end:" << seg_range[1]
  //             << ",\tslope: " << seg_range[2] * 100 << "%" << std::endl;
  // }
}
```

src/display.cpp
```
#include "display.h"
#include "SDL3/SDL_rect.h"
#include "pch.hpp"
#include "texturemanager.h"
#include <SDL3/SDL.h>
#include <SDL3_ttf/SDL_ttf.h>
#include <vector>

CourseDrawable::CourseDrawable(const Course* course_) : course(course_) {}

void CourseDrawable::render(const RenderContext* ctx) {
  const std::vector<Vector2d>& world_pts = course->visual_points;

  if (world_pts.empty())
    return;

  std::vector<SDL_FPoint> screen_points;
  screen_points.reserve(world_pts.size());

  // this loop can be optimized but apparently for <10k points, its instant
  auto camera = ctx->camera_weak.lock();
  if (!camera) {
    SDL_Log("failed to lock camera weak_ptr");
    return;
  }
  for (const auto& wp : world_pts) {
    if (abs(wp.x() - camera->get_pos().x()) > 2000)
      continue;

    Vector2d sp = camera->world_to_screen(wp);
    screen_points.push_back(SDL_FPoint{(float)sp.x(), (float)sp.y()});
  }

  SDL_SetRenderDrawColor(ctx->renderer, 200, 200, 200, 255);
  // SDL_RenderLines(ctx->renderer, points, pts.rows());
  // delete[] points;
  SDL_RenderLines(ctx->renderer, screen_points.data(), screen_points.size());
};

void RiderDrawable::render(const RenderContext* ctx) {
  // if (ctx->rider_snapshots->size() == 0) {
  //   throw std::runtime_error(
  //       "rider snapshots are empty (RiderDrawable::render)");
  // }
  if (!ctx->rider_snapshots || ctx->rider_snapshots->empty()) {
    return;
  }

  SDL_SetRenderDrawColor(ctx->renderer, 0, 255, 0, 255);
  // Draw each rider as a small 6×6 filled rect, centered on its screen‐space
  // pos
  for (const auto& [id, rider_snapshot] : *ctx->rider_snapshots) {
    auto cam = ctx->camera_weak.lock();
    if (!cam) {
      SDL_Log("failed to lock camera weak_ptr");
      return;
    }
    Vector2d screen_pos = cam->world_to_screen(rider_snapshot.pos2d);
    // SDL_Log("%.1f %.1f", rider_snapshot.pos2d.x(), rider_snapshot.pos2d.y());
    float w = 128;
    float h = 128;
    float x = static_cast<float>(screen_pos.x()) - w;
    float y = static_cast<float>(screen_pos.y()) - h;
    const SDL_FRect dst = SDL_FRect{x, y, w, h};
    const SDL_FRect src = SDL_FRect{0, 0, 256, 256};
    const SDL_Texture* tex =
        ctx->resources->get_textureManager()->get_texture("player");
    if (!tex) {
      SDL_Log("Missing texture 'player' while rendering tider %ld",
              (long)rider_snapshot.uid);
      continue;
    }
    SDL_RenderTexture(ctx->renderer, const_cast<SDL_Texture*>(tex), &src, &dst);
    SDL_FRect r{x - 3.0f, y - 3.0f, 6.0f, 6.0f};
    SDL_RenderFillRect(ctx->renderer, &r);
  }
}
```

src/haha.cpp
```
int main() { return 0; }
```

src/helpers.cpp
```
#include <SDL3/SDL.h>
#include <iostream>

void convert_color(SDL_Surface* surf) {
    SDL_LockSurface(surf);

    int w = surf->w;
    int h = surf->h;
    int pitch = surf->pitch;
    auto details = SDL_GetPixelFormatDetails(surf->format);
    int bpp = details->bytes_per_pixel;

    for (int y = 0; y < h; y++) {
        Uint8* row = (Uint8*)surf->pixels + y * pitch;
        for (int x = 0; x < w; x++) {
            Uint8* pixelPtr = row + x * bpp;
            Uint32 rawpixel = 0;

            // 1) Read exactly bpp bytes into a Uint32:
            switch (bpp) {
            case 1:
                rawpixel = *pixelPtr;
                break;
            case 2:
                rawpixel = *(Uint16*)pixelPtr;
                break;
            case 3:
                if (SDL_BYTEORDER == SDL_BIG_ENDIAN) {
                    rawpixel = (pixelPtr[0] << 16) | (pixelPtr[1] << 8) | pixelPtr[2];
                } else {
                    rawpixel = pixelPtr[0] | (pixelPtr[1] << 8) | (pixelPtr[2] << 16);
                }
                break;
            case 4:
                rawpixel = *(Uint32*)pixelPtr;
                break;
            }

            // 2) Extract R,G,B,A:
            Uint8 r, g, b, a;
            SDL_GetRGBA(rawpixel, details, nullptr, &r, &g, &b, &a);

            // 3) Decide if we want to repaint it:
            if (r > 120 && g < 20 && b > 120) {
                Uint8 newR = 255;
                Uint8 newG = 0;
                Uint8 newB = 255;
                // keep same alpha
                Uint32 new_pixel = SDL_MapRGBA(details, nullptr, newR, newG, newB, a);

                // 4) Write exactly bpp bytes back:
                switch (bpp) {
                case 1:
                    *pixelPtr = (Uint8)(new_pixel & 0xFF);
                    break;
                case 2:
                    *(Uint16*)pixelPtr = (Uint16)(new_pixel & 0xFFFF);
                    break;
                case 3:
                    if (SDL_BYTEORDER == SDL_BIG_ENDIAN) {
                        pixelPtr[0] = (new_pixel >> 16) & 0xFF;
                        pixelPtr[1] = (new_pixel >> 8) & 0xFF;
                        pixelPtr[2] = (new_pixel >> 0) & 0xFF;
                    } else {
                        pixelPtr[0] = (new_pixel >> 0) & 0xFF;
                        pixelPtr[1] = (new_pixel >> 8) & 0xFF;
                        pixelPtr[2] = (new_pixel >> 16) & 0xFF;
                    }
                    break;
                case 4:
                    *(Uint32*)pixelPtr = new_pixel;
                    break;
                }
            }
        }
    }

    SDL_UnlockSurface(surf);
}

SDL_Surface* load_transparent_bmp(const char* filename) {
    // The final texture
    SDL_Texture* newTexture = NULL;

    // Load image at specified path
    SDL_Surface* surf = SDL_LoadBMP(filename);

    convert_color(surf);
    // Color key image
    const SDL_PixelFormatDetails* fmt_details = SDL_GetPixelFormatDetails(surf->format);
    SDL_SetSurfaceColorKey(surf, true, SDL_MapRGB(fmt_details, nullptr, 0xFF, 0, 0xFF));

    return surf;
}

const SDL_Texture* load_from_file(SDL_Renderer* renderer, const char* filename) {
    SDL_Surface* surf = load_transparent_bmp(filename);
    if (!surf) {
        std::cerr << "IMG_Load Error: " << SDL_GetError() << "\n";
        return NULL;
    }
    // 2) Create texture
    SDL_Texture* tex = SDL_CreateTextureFromSurface(renderer, surf);
    if (!tex) {
        std::cerr << "SDL_CreateTextureFromSurface Error: " << SDL_GetError() << "\n";
        SDL_DestroySurface(surf);
        return NULL;
    }

    // 3) Save dimensions
    // int width = surf->w;
    // int height = surf->h;

    SDL_DestroySurface(surf);
    return tex;
}
```

src/main.cpp
```
#include "SDL3/SDL_events.h"
#include "SDL3/SDL_init.h"
#include "appstate.h"
#include "sim.h"
#include <chrono>
#include <exception>
#define SDL_MAIN_USE_CALLBACKS 1 /* use the callbacks instead of main() */
#include "screen.h"
#include <SDL3/SDL.h>
#include <SDL3/SDL_main.h>

int SCREEN_WIDTH = 1000;
int SCREEN_HEIGHT = 640;
int WORLD_WIDTH = 400;

SDL_AppResult SDL_AppInit(void** appstate, int argc, char* argv[]) {
  try {
    auto* state = new AppState();

    Team team("Team1");
    Rider* r = Rider::create_generic(team);
    state->sim->get_engine()->add_rider(r);

    Rider* r2 = new Rider("Pedro", 320, 90, 0.3, Bike::create_generic(), team);
    r2->pos = 20;
    state->sim->get_engine()->add_rider(r2);

    state->physics_thread =
        new std::thread([sim = state->sim]() { sim->start_realtime(); });

    // state->window =
    //     SDL_CreateWindow("Cycling Sim", SCREEN_WIDTH, SCREEN_HEIGHT, 0);
    // state->renderer = SDL_CreateRenderer(state->window, nullptr);

    state->switch_screen(ScreenType::Simulation);

    *appstate = state;
    return SDL_APP_CONTINUE;
  } catch (const std::exception& e) {
    SDL_Log("Application init failed: %s", e.what());
    return SDL_APP_FAILURE;
  }
}

/* This function runs when a new event (mouse input, keypresses, etc) occurs. */
SDL_AppResult SDL_AppEvent(void* appstate, SDL_Event* event) {
  auto* state = static_cast<AppState*>(appstate);
  if (event->type == SDL_EVENT_QUIT) {
    return SDL_APP_SUCCESS; /* end the program, reporting success */
  }

  // Pass event to current screen
  if (state->current_screen_ptr) {
    state->current_screen_ptr->handle_event(event);
  }

  return SDL_APP_CONTINUE; /* carry on with the program! */
}

/* This function runs once per frame, and is the heart of the program. */
SDL_AppResult SDL_AppIterate(void* appstate) {
  auto* state = static_cast<AppState*>(appstate);

  auto now = std::chrono::steady_clock::now();
  std::chrono::duration<double> dt = now - state->last_frame_time;

  if (dt.count() >= 1.0 / state->FPS) {
    state->current_screen_ptr->update();
    state->current_screen_ptr->render();
    state->last_frame_time = now;
  } else {
    double remaining = (1.0 / state->FPS) - dt.count();
    std::this_thread::sleep_for(std::chrono::duration<double>(remaining));
  }

  if (state->sim->physics_error) {
    SDL_Log("Physics thread exception: %s",
            state->sim->physics_error_message.c_str());

    state->sim->stop();
    // switch to error screen, pause sim, etc.
  }

  return SDL_APP_CONTINUE; /* carry on with the program! */
}

/* This function runs once at shutdown. */
void SDL_AppQuit(void* appstate, SDL_AppResult result) {
  auto* state = static_cast<AppState*>(appstate);

  delete state;
}
```

src/rider.cpp
```
#include "rider.h"
#include "course.h"
#include <cmath>
#include <exception>
#include <iostream>
// for std::setprecision
#include <iomanip>

#include "helpers.h"

size_t Rider::global_id_counter = 0;

const double ETOL = 1e-1; // W
const double ERTOL = 1e-3;
const double PTOL = 2e-3; // m/s
const double PRTOL = 1e-4;

const double RHO = 1.2234;
const double G = 9.80665;

const double PI = 3.14159265358979323846;

bool is_close(double value, double target, double tol, double rtol) {
  return std::fabs(value - target) <= tol + rtol * std::fabs(target);
}

Bike::Bike(double mass_, double wheel_i_, double wheel_r_,
           double wheel_drag_factor_, double crr_, double dt_loss_)
    : mass(mass_), wheel_i(wheel_i_), wheel_r(wheel_r_),
      wheel_drag_factor(wheel_drag_factor_), crr(crr_), dt_loss(dt_loss_) {}

Bike Bike::create_generic() { return Bike(7.0, 0.14, 0.311, 0, 0.006, 0.02); }

Team::Team(const char* name_) : name(name_) { id = 0; }

Rider::Rider(std::string name_, double ftp_base_, double mass_, double cda_,
             Bike bike_, Team team_)
    : uid(global_id_counter++), name(name_), ftp_base(ftp_base_), mass(mass_),
      cda(cda_), bike(bike_), team(team_) {
  cda_factor = 1.0;
  target_effort = 0.8;
  pos = 0;
  speed = 0;
  slope = 0;

  heading = PI / 3;

  set_cda_factor(1);
  change_bike(bike);

  timestep = 1;
}

Rider* Rider::create_generic(Team team_) {
  Bike bike = Bike::create_generic();
  return new Rider("Joe Moe", 250, 65, 0.3, bike, team_);
}

void Rider::set_course(const ICourseView* cv) { course = cv; }

std::ostream& operator<<(std::ostream& os, const Rider& r) {
  os << std::fixed << std::setprecision(1) << r.name << ":\t" << r.ftp_base
     << " W\t" << r.mass << " kg\npos: " << r.pos
     << "m\tspeed: " << r.speed * 3.6 << " km/h" << std::endl;
  return os;
}

Vector2d Rider::get_pos2d() const { return _pos2d; }

void Rider::set_pos2d(Vector2d pos) { _pos2d = pos; }

void Rider::set_cda_factor(double cda_factor_) {
  cda_factor = cda_factor_;
  effective_cda = cda_factor * cda;
  compute_drag();
}

void Rider::set_mass(double rider_mass) {
  mass = rider_mass;
  total_mass = rider_mass + bike.mass;
  compute_roll();
  compute_drag();
  compute_inertia();
}

void Rider::compute_headwind() {
  Wind wind = course->get_wind(pos);
  v_hw = wind.speed * cos(wind.heading - this->heading);
}

void Rider::compute_drag() {
  drag_coeff = 0.5 * RHO * (effective_cda + bike.wheel_drag_factor);
}

void Rider::compute_roll() { roll_coeff = bike.crr * total_mass * G; }

void Rider::compute_inertia() {
  mass_ir = total_mass + bike.wheel_i / pow(bike.wheel_r, 2);
  inertia_coeff = 0.5 * mass_ir;
}

void Rider::compute_coeff() {
  compute_drag();
  compute_roll();
  compute_inertia();
}

void Rider::change_bike(Bike new_bike) {
  bike = new_bike;
  total_mass = mass + bike.mass;
  f_grav = total_mass * G;
  compute_coeff();
}

void Rider::reset() {
  pos = 0;
  speed = 0;
  // TODO - reset energymodel!
}

void Rider::update(double dt) {
  timestep = dt;
  slope = course->get_slope(pos);
  compute_headwind();
  double ftp = ftp_base;
  // this comes from energymodel
  double effort_limit = 1;
  power = std::min(target_effort, effort_limit) * ftp;
  // energy_model.update(power, timestep);
  try {
    speed = newton(power, speed);
  } catch (std::exception e) {
    // TODO -  what here?
  }
  pos += timestep * speed;
  altitude = course->get_altitude(pos);
  set_pos2d(Vector2d{pos, altitude});
}

double Rider::km() const { return pos / 1000.0; }

double Rider::km_h() const { return speed * 3.6; }

double Rider::pow_speed(double new_speed) const {
  double v_air = new_speed + v_hw;
  return (drag_coeff * pow(v_air, 2) * new_speed + roll_coeff * new_speed +
          (0.091 + 0.0087 * new_speed) * new_speed +
          f_grav * sin(atan(slope)) * new_speed +
          inertia_coeff * (pow(new_speed, 2) - pow(speed, 2)) / timestep) /
         (1 - bike.dt_loss);
}

double Rider::pow_speed_prime(double new_speed) {
  double v_air = new_speed + v_hw;
  return (drag_coeff * (2 * v_air * new_speed + pow(v_air, 2)) + roll_coeff +
          0.091 + 0.0174 * new_speed + f_grav * sin(atan(slope)) +
          inertia_coeff * 2 * new_speed / timestep) /
         (1 - bike.dt_loss);
}

double Rider::pow_speed_double_prime(double new_speed) {
  double v_air = new_speed + v_hw;
  return (drag_coeff * (2 * new_speed + 4 * v_air) + 0.0174 +
          inertia_coeff * 2 / timestep) /
         (1 - bike.dt_loss);
}

double Rider::newton(double power, double speed_guess, int max_iterations) {
  double x = speed_guess;
  double x_next;
  double f, f_prime;

  for (int i = 0; i < max_iterations; ++i) {
    f = pow_speed(x) - power;
    f_prime = pow_speed_prime(x);

    if (std::abs(f_prime) < 1e-12) {
      throw std::runtime_error("Derivative too small.");
    }

    x_next = x - f / f_prime;

    // std::cout << "error: " << f << "\tprecision: " << x_next - x <<
    // std::endl;

    if (is_close(f, 0, ETOL, ERTOL) || is_close(x_next, x, PTOL, PRTOL)) {
      return x_next;
    }

    x = x_next;
  }

  throw std::runtime_error("Did not converge. Reached max iterations: " +
                           std::to_string(max_iterations));
}

double Rider::householder(double power, double speed_guess,
                          int max_iterations) {
  double x = speed_guess;
  double x_next;
  double f, f_prime, f_double_prime;

  for (int i = 0; i < max_iterations; ++i) {
    f = pow_speed(x) - power;
    f_prime = pow_speed_prime(x);
    f_double_prime = pow_speed_double_prime(x); // must define this

    if (std::abs(f_prime) < 1e-12) {
      throw std::runtime_error("Derivative too small.");
    }

    double correction = (f / f_prime);
    correction *= (1.0 + (f * f_double_prime) / (2.0 * f_prime * f_prime));

    x_next = x - correction;

    std::cout << "error: " << f << "\tprecision: " << x_next - x << std::endl;

    if (is_close(f, 0, ETOL, ERTOL) || is_close(x_next, x, PTOL, PRTOL)) {
      return x_next;
    }

    x = x_next;
  }

  throw std::runtime_error("Did not converge. Reached max iterations: " +
                           std::to_string(max_iterations));
}

RiderSnapshot Rider::snapshot() const {
  return RiderSnapshot{
      .uid = this->uid,
      .name = this->name,
      .pos = this->pos,
      .slope = this->slope,
      .pos2d = this->_pos2d,
      .power = this->power,
      .speed = this->speed,
      .km_h = this->km_h(),
      .heading = this->heading,
      .team_id = this->team.id,
  };
}
```

src/screen.cpp
```
#include "screen.h"
#include "simulationrenderer.h"
#include "snapshot.h"
#include "widget.h"
#include <memory>

void MenuScreen::render() {
  SDL_SetRenderDrawColor(state->renderer, 30, 30, 30, 255);
  SDL_RenderClear(state->renderer);

  // draw a simple "Press ENTER" text
  // you probably have font rendering already via resources

  SDL_RenderPresent(state->renderer);
}

void ResultsScreen::render() {
  SDL_SetRenderDrawColor(state->renderer, 0, 0, 0, 255);
  SDL_RenderClear(state->renderer);

  // show rider stats
  // auto snap1 = state->sim->get_engine()->snapshot_of(state->r1);
  // auto snap2 = state->sim->get_engine()->snapshot_of(state->r2);

  // draw simple text:
  // "Rider1 final pos: 123.4"
  // "Rider2 final pos: 110.2"

  SDL_RenderPresent(state->renderer);
}

SimulationScreen::SimulationScreen(AppState* s) : state(s) {
  Vector2d screensize(s->SCREEN_WIDTH, s->SCREEN_HEIGHT);
  // maybe this could take screensize rather than 2 ints?
  // display = new DisplayEngine(state, screensize, WORLD_WIDTH);
  auto cam = std::make_shared<Camera>(s->course, WORLD_WIDTH, screensize);
  sim_renderer = std::make_unique<SimulationRenderer>(s->renderer, s->resources,
                                                      s->sim, cam);

  TTF_Font* default_font =
      state->resources->get_fontManager()->get_font("default");

  sim_renderer->add_world_drawable(
      std::make_unique<CourseDrawable>(state->sim->get_engine()->get_course()));
  sim_renderer->add_world_drawable(std::make_unique<RiderDrawable>());

  sim_renderer->add_drawable(std::make_unique<Stopwatch>(
      20, 20, state->resources->get_fontManager()->get_font("stopwatch"),
      state->sim));

  sim_renderer->add_drawable(std::make_unique<TimeControlPanel>(
      400, 20, 40, default_font, state->sim));

  // 2. Create the Panel
  auto panel = std::make_unique<RiderPanel>(20, 120, default_font);

  // 3. Add Rows (Using Lambdas for custom logic)

  // SPEED
  panel->add_row("Speed", "km/h", [](const RiderSnapshot& s) {
    return format_number(s.km_h, 2);
  });

  // POWER
  panel->add_row("Power", "W", [](const RiderSnapshot& s) {
    return format_number(s.power, 0); // Precision 0 for watts
  });

  // DISTANCE
  panel->add_row("Dist", "km", [](const RiderSnapshot& s) {
    return format_number(s.pos / 1000.0);
  });

  // GRADIENT (Custom logic inside lambda!)
  panel->add_row("Grad", "%", [](const RiderSnapshot& s) {
    // Assuming you add 'slope' to RiderSnapshot
    // return format_number(s.slope * 100.0);
    return format_number(s.slope * 100.0);
  });

  RiderPanel* p = panel.get();

  sim_renderer->set_rider_panel(p);
  sim_renderer->add_drawable(std::move(panel));

  // display->add_drawable(std::make_unique<ValueField>(
  //     300, 300, 5, resources->get_fontManager()->get_font("default"), 0,
  //     [](const RiderSnapshot& s) -> std::string { return s.name; }));
  // display->add_drawable(std::make_unique<ValueFieldPanel>(
  //     300, 400, state->resources->get_fontManager()->get_font("default"),
  //     r));

  // camera->set_target_rider(state->sim->get_engine()->get_rider(0));
}

void SimulationScreen::update() { sim_renderer->update(); }

void SimulationScreen::render() { sim_renderer->render_frame(); }

bool SimulationScreen::handle_event(const SDL_Event* e) {
  if (sim_renderer->handle_event(e))
    return true;

  switch (e->type) {
  case SDL_EVENT_MOUSE_BUTTON_DOWN:
    if (e->button.button == SDL_BUTTON_LEFT) {
      int uid = sim_renderer->pick_rider(e->button.x, e->button.y);

      if (uid != -1) {
        selected_rider_uid = uid;
        // sim_renderer->get_camera()->set_target(uid);
        sim_renderer->get_camera()->set_target_id(uid);
        sim_renderer->get_rider_panel()->set_rider_id(uid);
        return true;
      }
    }
    if (e->button.button == SDL_BUTTON_RIGHT) {
      // Start dragging for camera pan
      dragging = true;
      drag_start_x = e->button.x;
      drag_start_y = e->button.y;
      return true;
    }
    break;

    // button released
  case SDL_EVENT_MOUSE_BUTTON_UP:
    if (e->button.button == SDL_BUTTON_RIGHT) {
      dragging = false;
      return true;
    }
    break;

  case SDL_EVENT_MOUSE_WHEEL:
    // sim_renderer->get_camera()->zoom(e.wheel.y * 0.1);
    // return true;
    break;

  case SDL_EVENT_KEY_DOWN:
    if (e->key.key == SDLK_ESCAPE)
      state->switch_screen(ScreenType::Menu);
    break;
  }
  return true;
}
```

src/sim.cpp
```
#include "sim.h"
#include <chrono>
#include <thread>

PhysicsEngine::PhysicsEngine(const Course* c) : course(c) {}

void PhysicsEngine::add_rider(Rider* r) {
  std::lock_guard<std::mutex> lock(frame_mtx);
  riders.push_back(r);
  r->set_course(course);
}

void PhysicsEngine::update(double dt) {
  for (Rider* r : riders) {
    r->update(dt);
    // std::cout << "pos: " << r->pos << "\tm\nspeed: " << 3.6 * r->speed <<
    // "\tkm/h\n" << std::endl;
  }
}

// Expose a way for the render thread to grab the same mutex.
// We need this so that rendering can “lock frame_mtx” before reading any Rider
// state.
std::mutex* PhysicsEngine::get_frame_mutex() const { return &frame_mtx; }

const std::vector<Rider*>& PhysicsEngine::get_riders() const { return riders; }

// this is (now) only used to set camera to first rider... kinda useless if
// fixed
const Rider* PhysicsEngine::get_rider(int idx) const { return riders.at(idx); }

PhysicsEngine::~PhysicsEngine() {
  // WARNING - if riders have textures or other dependencies
  // we need to be careful here
  for (Rider* r : riders) {
    delete r;
  }
}

Simulation::Simulation(const Course* c) : engine(c) {}

void Simulation::start_realtime() {
  running = true;
  double accumulator = 0.0;
  double sim_step;

  auto t_prev = std::chrono::steady_clock::now();

  while (running) {
    auto t_now = std::chrono::steady_clock::now();
    double frame_time = std::chrono::duration<double>(t_now - t_prev).count();
    t_prev = t_now;

    accumulator += frame_time * time_factor;
    if (accumulator > 0.25) {
      SDL_Log("accumulator %f > 0.25 s. Setting to 0.25s.", accumulator);
      accumulator = 0.25;
    }

    while (accumulator >= dt) {
      auto step_start = std::chrono::steady_clock::now();

      try {
        step_fixed(dt);
      } catch (const std::exception& e) {
        physics_error = true;
        physics_error_message = e.what();
        running = false;
      }
      accumulator -= dt;

      // what follows is only to check for exceeding the time
      auto step_end = std::chrono::steady_clock::now();
      double step_time =
          std::chrono::duration<double>(step_end - step_start).count();
      if (step_time > dt) {
        SDL_Log("Hey! engine.update(dt=%f) took %f. spiral of death!", dt,
                step_time);
      }
    }
    // After you’ve done zero or more physics steps,
    // you can sleep a tiny bit (to release thread?)
    std::this_thread::sleep_for(std::chrono::milliseconds(1));
  }
}

void Simulation::step_fixed(double dt) {
  std::lock_guard<std::mutex> phys_lock(*engine.get_frame_mutex());
  engine.update(dt);
  sim_seconds += dt;
}

void Simulation::run_max_speed(const SimulationCondition& cond) {
  using namespace std::chrono;

  const int secs = 180;
  const auto timeout = seconds(secs);
  const auto start_time = steady_clock::now();
  int iteration = 1;

  while (!cond.is_met(*this)) {
    try {
      step_fixed(dt);
    } catch (const std::exception& e) {
      physics_error = true;
      physics_error_message = e.what();
      break;
    }

    if (++iteration % 100 == 0) {
      if (steady_clock::now() - start_time > timeout) {
        SDL_Log("Timeout %d seconds after %d iterations", secs, iteration);
        break;
      }
    }
  }
}

void Simulation::stop() { running = false; }

const double Simulation::get_sim_seconds() const { return sim_seconds; }

class TimeReached : public SimulationCondition {
  double limit;

public:
  explicit TimeReached(double limit_seconds) : limit(limit_seconds) {}

  bool is_met(const Simulation& sim) const override {
    return sim.get_sim_seconds() >= limit;
  }
};

class RiderFinished : public SimulationCondition {
  int rider_index;

public:
  RiderFinished(int idx) : rider_index(idx) {}

  bool is_met(const Simulation& sim) const override {
    std::vector<Rider*> riders = sim.get_engine()->get_riders();
    bool met = false;
    for (Rider* r : riders) {
      if (r->pos >= sim.get_engine()->get_course_length()) {
        met = true;
      }
    }
    return met;
  }
};

const PhysicsEngine* Simulation::get_engine() const { return &engine; }
PhysicsEngine* Simulation::get_engine() { return &engine; }
```

src/simulationrenderer.cpp
```
#include "simulationrenderer.h"
#include "sim.h"
#include <memory>
#include <mutex>

SimulationRenderer::SimulationRenderer(SDL_Renderer* r,
                                       GameResources* resources,
                                       Simulation* sim_,
                                       std::shared_ptr<Camera> cam)
    : CoreRenderer(r, resources), sim(sim_), camera(std::move(cam)) {
  build_and_swap_snapshots();
  if (snapshot_front.count(0)) {
    camera->set_center(snapshot_front.at(0).pos2d);
  }
}

void SimulationRenderer::add_world_drawable(std::unique_ptr<Drawable> d) {
  world_drawables.push_back(std::move(d));
}

void SimulationRenderer::build_and_swap_snapshots() {
  snapshot_back.clear();

  PhysicsEngine* engine = sim->get_engine();

  {
    // protects only reading rider data
    std::lock_guard<std::mutex> phys_lock(*engine->get_frame_mutex());

    const auto& riders = engine->get_riders();
    for (const Rider* r : riders) {
      if (!r)
        continue;
      snapshot_back.emplace(r->get_id(), r->snapshot());
    }
  }

  {
    // protects only swapping pointers to maps (instant)
    std::lock_guard<std::mutex> lock(snapshot_swap_mtx);
    snapshot_front.swap(snapshot_back);
  }
}

void SimulationRenderer::update() {
  // First gather snapshots
  build_and_swap_snapshots();
  camera->update(snapshot_front);
}

void SimulationRenderer::render_frame() {
  SDL_SetRenderDrawColor(renderer, 30, 30, 30, 255);
  SDL_RenderClear(renderer);

  RenderContext ctx;
  ctx.renderer = renderer;
  ctx.resources = resources;
  ctx.camera_weak = camera;
  ctx.rider_snapshots = &snapshot_front;

  // 1. Draw world-space drawables
  int cnt = 0;
  for (auto& d : world_drawables) {
    d->render(&ctx);
  }

  // 2. Draw UI drawables (inherited from CoreRenderer)
  cnt = 0;
  for (auto& d : drawables) {
    d->render(&ctx);
  }

  SDL_RenderPresent(renderer);
}

// TODO - make this safe - there is a suggestion in "Code review feedback" chat
// in chatGPT from 26.11.2025
int SimulationRenderer::pick_rider(double screen_x, double screen_y) const {
  if (!camera)
    return -1;

  Vector2d world_pos = camera->screen_to_world(Vector2d(screen_x, screen_y));

  double min_dist = 20.0;
  bool found = false;
  size_t found_id = 0;
  SDL_Log("\n%.1f, %.1f", world_pos.x(), world_pos.y());

  std::lock_guard<std::mutex> lock(snapshot_swap_mtx);
  for (auto& [id, snap] : snapshot_front) {
    double dx = snap.pos2d.x() - world_pos.x();
    double dy = snap.pos2d.y() - world_pos.y();
    double dist = std::sqrt(dx * dx + dy * dy);
    SDL_Log("%s: %.1f", snap.name.c_str(), dist);

    // you might wanna weight X more strictly if they are packed tight
    if (dist < min_dist) {
      min_dist = dist;
      found_id = id;
      found = true;
    }
  }

  if (found) {
    SDL_Log("Selected rider ID: %lu", (unsigned long)found_id);
    return found_id;
  }
  return -1;
}

bool SimulationRenderer::handle_event(const SDL_Event* e) {
  // UI above world
  for (auto& d : drawables)
    if (d->handle_event(e))
      return true;

  for (auto& d : world_drawables)
    if (d->handle_event(e))
      return true;

  return false;
}
```

src/texturemanager.cpp
```
#include "texturemanager.h"
#include "SDL3_ttf/SDL_ttf.h"
#include <SDL3/SDL.h>
#include <SDL3_image/SDL_image.h>
#include <iostream>
#include <unordered_map>

// You must give TextureManager a valid SDL_Renderer* at construction time.
// It keeps that renderer internally so it can turn surfaces → textures.
TextureManager::TextureManager(SDL_Renderer* renderer) : renderer(renderer) {}

TextureManager::~TextureManager() {
  // Destroy all SDL_Texture* that we have loaded.
  for (auto& kv : texture_map) {
    if (kv.second) {
      SDL_DestroyTexture(kv.second);
    }
  }
}

// Try to load a texture from `filePath` and store it under the key `id`.
// Returns true if successful (or if the key already existed).
bool TextureManager::load_texture(const char* id, const char* file_path) {
  // If we've already loaded “id”, do nothing.
  if (texture_map.count(id)) {
    return true;
  }

  SDL_Surface* surf = IMG_Load(file_path);
  if (!surf) {
    std::cerr << "IMG_Load Error (" << file_path << "): " << SDL_GetError()
              << "\n";
    return false;
  }

  SDL_Texture* tex = SDL_CreateTextureFromSurface(renderer, surf);
  SDL_DestroySurface(surf);

  if (!tex) {
    std::cerr << "SDL_CreateTextureFromSurface Error (" << file_path
              << "): " << SDL_GetError() << "\n";
    return false;
  }

  texture_map[id] = tex;
  return true;
}

// Retrieve the texture pointer for a given id (returns nullptr if not found).
TTF_Font* FontManager::get_font(const char* id) const {
  auto it = font_map.find(id);
  if (it == font_map.end())
    return nullptr;
  return it->second;
}

// (Optional) Query width/height of a loaded texture.
bool TextureManager::query_texture(const char* id, float& outW,
                                   float& outH) const {
  SDL_Texture* tex = get_texture(id);
  if (!tex)
    return false;
  if (0 != SDL_GetTextureSize(tex, &outW, &outH)) {
    std::cerr << "SDL_QueryTexture Error: " << SDL_GetError() << "\n";
    return false;
  }
  return true;
}

// Retrieve the texture pointer for a given id (returns nullptr if not found).
SDL_Texture* TextureManager::get_texture(const char* id) const {
  auto it = texture_map.find(id);
  if (it == texture_map.end())
    return nullptr;
  return it->second;
}

bool FontManager::load_font(const char* id, const char* file_path,
                            int font_size) {
  if (font_map.count(id)) {
    return true;
  }

  char* font_path = NULL;
  SDL_asprintf(&font_path, "%s/../%s", SDL_GetBasePath(), file_path);
  TTF_Font* font = TTF_OpenFont(font_path, font_size);
  if (!font) {
    SDL_Log("Couldn't load font: %s", SDL_GetError());
    return false;
  }
  SDL_free(font_path);

  font_map[id] = font;
  return true;
}

FontManager::~FontManager() {
  // Destroy all SDL_Texture* that we have loaded.
  for (auto& kv : font_map) {
    if (kv.second) {
      // free(kv.second);
      TTF_CloseFont(kv.second);
    }
  }
}
```

src/widget.cpp
```
#include <SDL3/SDL.h>
#include <SDL3_ttf/SDL_ttf.h>
#include <cstdio>
#include <string>

#include "SDL3/SDL_log.h"
#include "SDL3/SDL_render.h"
#include "SDL3/SDL_surface.h"
#include "display.h"
#include "widget.h"
// for std::setprecision
// #include <iomanip>

std::string format_number(double value, int precision) {
  char buffer[32];
  snprintf(buffer, sizeof(buffer), "%.*f", precision, value);
  return std ::string(buffer);
}

void format_time(double seconds, char* text) {
  // Break down into components
  int totalTenths = static_cast<int>(round(seconds * 10));
  int tenths = totalTenths % 10;
  int totalSeconds = totalTenths / 10;
  int secs = totalSeconds % 60;
  int totalMinutes = totalSeconds / 60;
  int mins = totalMinutes % 60;
  int hours = totalMinutes / 60;

  // Format with leading zeros and fixed positions
  snprintf(text, 11, "%02d:%02d:%02d.%d", hours, mins, secs, tenths);
}

// std::pair<int, int> Widget::get_texture_size() const {
//   return {widget_w, widget_h};
// }

SDL_Texture* Stopwatch::render_time(SDL_Renderer* renderer, const char* s,
                                    int& out_w, int& out_h) {
  SDL_Surface* surf =
      TTF_RenderText_LCD(font, s, 0, text_color, SDL_Color{0, 0, 0, 200});
  if (!surf) {
    SDL_Log("TTF_RenderText_LCD failed: %s", SDL_GetError());
    return nullptr;
  }
  out_w = surf->w;
  out_h = surf->h;

  SDL_Texture* new_texture = SDL_CreateTextureFromSurface(renderer, surf);
  SDL_DestroySurface(surf);

  if (!new_texture) {
    SDL_Log("SDL_CreateTextureFromSurface failed: %s", SDL_GetError());
    return nullptr;
  }
  return new_texture;
}

void Stopwatch::update_texture(const RenderContext* ctx) {
  double sim_time = sim->get_sim_seconds();
  format_time(sim_time, text);

  if (texture) {
    SDL_DestroyTexture(texture);
    texture = nullptr;
  }
  texture = render_time(ctx->renderer, text, width, height);
}

void Stopwatch::render(const RenderContext* ctx) {
  // 1) Check if we need to build the background frame
  if (bg_texture == nullptr) {
    bg_texture = create_base(ctx->renderer);
  }

  // 2) Check if we need to update the time digits
  Uint32 now_ticks = SDL_GetTicks();
  if (texture == nullptr || (now_ticks - last_update_ticks) >=
                                static_cast<Uint32>(update_interval_ms)) {
    update_texture(ctx);
    last_update_ticks = now_ticks;
  }

  // 3) Draw Background Frame
  if (bg_texture) {
    // Note: The background includes padding, so it is larger than the text
    SDL_FRect dst{static_cast<float>(screen_x), static_cast<float>(screen_y),
                  static_cast<float>(bg_width), static_cast<float>(bg_height)};
    SDL_RenderTexture(ctx->renderer, bg_texture, nullptr, &dst);
  }

  // 4) Draw Text (inset by content_offset)
  if (texture) {
    // Note: width/height here refers to the BACKGROUND dimensions calculated in
    // create_base. We use texture size from the text itself for the source? No,
    // render_time set width/height? Wait, render_time sets 'width' and 'height'
    // MEMBER variables which overwrites the background size? FIX: The member
    // variables `width` and `height` should likely store the total widget size.
    // But render_time takes `width` and `height` by reference as `out_w`,
    // `out_h`.

    // Let's inspect the logic:
    // create_base sets `width` and `height` to the padded size.
    // update_texture calls render_time(..., width, height).
    // This effectively overwrites the widget size with the text size every
    // update! That is a bug in the provided code snippet, but I will implement
    // it as requested while fixing the overwrite to use local variables for the
    // text size so the background doesn't shrink.

    float txt_w, txt_h;
    SDL_GetTextureSize(texture, &txt_w, &txt_h);

    SDL_FRect dst = {static_cast<float>(screen_x + content_offset),
                     static_cast<float>(screen_y + content_offset),
                     static_cast<float>(txt_w), static_cast<float>(txt_h)};
    SDL_RenderTexture(ctx->renderer, texture, nullptr, &dst);
  }
}

SDL_Texture* Stopwatch::create_base(SDL_Renderer* renderer) {
  int w, h;
  // Calculate size based on a dummy string "00:00:00.0" to ensure fixed width
  TTF_GetStringSize(font, "00:00:00.0", 0, &w, &h);

  int padded_w = w + 2 * content_offset;
  int padded_h = h + 2 * content_offset;
  bg_width = padded_w;
  bg_height = padded_h;

  SDL_Surface* surf =
      SDL_CreateSurface(padded_w, padded_h, SDL_PIXELFORMAT_XRGB8888);
  if (!surf) {
    SDL_Log("SDL_CreateSurface failed: %s", SDL_GetError());
    return nullptr;
  }

  // Store the total size in member variables
  width = surf->w;
  height = surf->h;

  const SDL_PixelFormatDetails* fmt_details =
      SDL_GetPixelFormatDetails(surf->format);
  Uint32 transparent = SDL_MapRGBA(fmt_details, nullptr, 0, 0, 0, 0);
  Uint32 hlPix = SDL_MapRGBA(fmt_details, nullptr, 177, 177, 177, 255);
  Uint32 shPix = SDL_MapRGBA(fmt_details, nullptr, 77, 77, 77, 255);

  SDL_Rect r{0, 0, padded_w, padded_h};
  SDL_FillSurfaceRect(surf, &r, transparent);

  SDL_Rect topEdge = {0, 0, padded_w, edge_thickness};
  SDL_FillSurfaceRect(surf, &topEdge, hlPix);

  SDL_Rect leftEdge = {0, 0, edge_thickness, padded_h};
  SDL_FillSurfaceRect(surf, &leftEdge, hlPix);

  SDL_Rect bottomEdge = {0, padded_h - edge_thickness, padded_w,
                         edge_thickness};
  SDL_FillSurfaceRect(surf, &bottomEdge, shPix);

  SDL_Rect rightEdge = {padded_w - edge_thickness, 0, edge_thickness, padded_h};
  SDL_FillSurfaceRect(surf, &rightEdge, shPix);

  SDL_Texture* tex = SDL_CreateTextureFromSurface(renderer, surf);
  SDL_DestroySurface(surf);
  return tex;
}

void TimeFactorButton::render(const RenderContext* ctx) {
  SDL_Renderer* r = ctx->renderer;
  SDL_SetRenderDrawColor(r, 80, 80, 80, 255);
  SDL_FRect box{(float)x, (float)y, (float)w, (float)h};
  SDL_RenderFillRect(r, &box);

  char buf[12];
  // snprintf(buf, 12, "x%.0f", value);
  snprintf(buf, 12, "%.1fx", value);

  SDL_Surface* surf =
      TTF_RenderText_Blended(font, buf, 0, SDL_Color{255, 255, 255, 255});

  SDL_Texture* tex = SDL_CreateTextureFromSurface(r, surf);

  SDL_FRect dst{(float)(x + 5), (float)(y + 2), (float)surf->w, (float)surf->h};
  SDL_RenderTexture(r, tex, nullptr, &dst);

  SDL_DestroyTexture(tex);
  SDL_DestroySurface(surf);
}

bool TimeFactorButton::handle_event(const SDL_Event* e) {
  if (e->type == SDL_EVENT_MOUSE_BUTTON_DOWN &&
      e->button.button == SDL_BUTTON_LEFT) {
    if (e->button.x >= x && e->button.x <= x + w && e->button.y >= y &&
        e->button.y <= y + h) {
      sim->set_time_factor(value);
      return true;
    }
  }
  return false;
}

double TimeFactorSlider::slider_to_factor(double t) {
  if (t <= neutral_point) {
    double s = t / neutral_point;
    return 0.1 + s * (1.0 - 0.1);
  } else {
    double s = (t - neutral_point) / neutral_point;
    return std::pow(10.0, s * 2.0); // 1 → 100
  }
}

double TimeFactorSlider::factor_to_slider(double f) {
  if (f <= 1.0) {
    double s = (f - 0.1) / (1.0 - 0.1);
    return s * neutral_point;
  } else {
    double s = std::log10(f) / 2.0;
    return neutral_point + s * neutral_point;
  }
}

void TimeFactorSlider::render(const RenderContext* ctx) {
  SDL_Renderer* r = ctx->renderer;

  // background bar
  SDL_SetRenderDrawColor(r, 120, 120, 120, 255);
  SDL_FRect bar{(float)x, (float)y + h * 0.4f, (float)w, h * 0.2f};
  SDL_RenderFillRect(r, &bar);

  // neutral point - factor = 1.0
  float markerX = x + neutral_point * w - marker_width / 2.0;
  SDL_SetRenderDrawColor(r, 120, 120, 120, 255);
  SDL_FRect marker{markerX, (float)y, static_cast<float>(marker_width),
                   (float)h};
  SDL_RenderFillRect(r, &marker);

  // knob
  double t = factor_to_slider(sim->get_time_factor());
  float knobX = x + t * w - h / 4.0;
  SDL_SetRenderDrawColor(r, 240, 240, 240, 255);
  SDL_FRect knob{knobX, static_cast<float>(y + h / 4.0), (float)h / 2,
                 (float)h / 2};
  SDL_RenderFillRect(r, &knob);
}

bool TimeFactorSlider::handle_event(const SDL_Event* e) {
  switch (e->type) {
  case SDL_EVENT_MOUSE_BUTTON_DOWN:
    if (e->button.x >= x && e->button.x <= x + w && e->button.y >= y &&
        e->button.y <= y + h) {
      dragging = true;
      return true;
    }
    break;

  case SDL_EVENT_MOUSE_BUTTON_UP:
    dragging = false;
    break;

  case SDL_EVENT_MOUSE_MOTION:
    if (dragging) {
      double local = (e->motion.x - x) / (double)w;
      local = std::clamp(local, 0.0, 1.0);
      double f = slider_to_factor(local);
      sim->set_time_factor(f);
      return true;
    }
    break;
  }
  return false;
}

TimeControlPanel::TimeControlPanel(int x_, int y_, int h_, TTF_Font* font,
                                   Simulation* sim)
    : x(x_), y(y_), h(h_) {
  // Add slider
  children.push_back(std::make_unique<TimeFactorSlider>(x + 0, y + h_ / 4,
                                                        slider_w, h_ / 2, sim));

  // Add time buttons
  children.push_back(std::make_unique<TimeFactorButton>(
      x + 210, y + h_ / 4, h_ / 2, 0.5, sim, font));

  children.push_back(std::make_unique<TimeFactorButton>(
      x + 255, y + h_ / 4, h_ / 2, 1.0, sim, font));

  children.push_back(std::make_unique<TimeFactorButton>(
      x + 300, y + h_ / 4, h_ / 2, 10.0, sim, font));
}

void TimeControlPanel::render(const RenderContext* ctx) {
  SDL_Renderer* r = ctx->renderer;

  // (Optional) panel background
  SDL_SetRenderDrawColor(r, 40, 40, 40, 200);
  SDL_FRect bg{(float)x, (float)y, 350.f, static_cast<float>(h)};
  SDL_RenderFillRect(r, &bg);

  // Children
  for (auto& w : children)
    w->render(ctx);
}

bool TimeControlPanel::handle_event(const SDL_Event* e) {
  for (auto& w : children)
    if (w->handle_event(e))
      return true;

  return false;
}

ValueField::ValueField(int x_, int y_, int w, int h, TTF_Font* f, size_t id,
                       DataGetter g)
    : x(x_), y(y_), width(w), height(h), font(f), target_rider_id(id),
      getter(g) {}

ValueField::~ValueField() {
  if (texture)
    SDL_DestroyTexture(texture);
  if (bg_texture)
    SDL_DestroyTexture(bg_texture);
}

void ValueField::create_bg(SDL_Renderer* renderer) {
  // Create a dark gray box background
  SDL_Surface* surf =
      SDL_CreateSurface(width, height, SDL_PIXELFORMAT_RGBA8888);
  SDL_FillSurfaceRect(surf, nullptr,
                      SDL_MapRGBA(SDL_GetPixelFormatDetails(surf->format),
                                  nullptr, 50, 50, 50, 255));
  bg_texture = SDL_CreateTextureFromSurface(renderer, surf);
  SDL_DestroySurface(surf);
}

void ValueField::update_texture(SDL_Renderer* renderer,
                                const RiderSnapshot& snap) {
  // 1. Get string from lambda
  std::string new_text = getter(snap);

  // 2. Only re-render if text changed (Optimization)
  if (new_text == current_text && texture)
    return;

  current_text = new_text;
  if (texture)
    SDL_DestroyTexture(texture);

  // 3. Render Text
  SDL_Surface* surf =
      TTF_RenderText_Blended(font, current_text.c_str(), 0, text_color);
  if (surf) {
    texture = SDL_CreateTextureFromSurface(renderer, surf);
    SDL_DestroySurface(surf);
  }
}

void ValueField::render_with_snapshot(const RenderContext* ctx,
                                      const RiderSnapshot* snap) {
  if (!snap)
    return;

  if (!bg_texture)
    create_bg(ctx->renderer);
  update_texture(ctx->renderer, *snap);
  // 3. Draw Background
  SDL_FRect bg_rect = {(float)x, (float)y, (float)width, (float)height};
  SDL_RenderTexture(ctx->renderer, bg_texture, nullptr, &bg_rect);

  // 4. Draw Text (Centered or Right Aligned)
  if (texture) {
    float tex_w, tex_h;
    SDL_GetTextureSize(texture, &tex_w, &tex_h);
    // Align right inside the box with padding
    float txt_x = x + width - tex_w - 5;
    float txt_y = y + (height - tex_h) / 2;
    SDL_FRect txt_rect = {txt_x, txt_y, tex_w, tex_h};
    SDL_RenderTexture(ctx->renderer, texture, nullptr, &txt_rect);
  }
}

// ======================= METRIC ROW =======================

MetricRow::MetricRow(int x_, int y_, TTF_Font* f, size_t id, std::string label,
                     std::string unit, ValueField::DataGetter getter)
    : x(x_), y(y_), font(f), label_txt(label), unit_txt(unit) {

  // Create the child ValueField (Width 80, Height 24)
  // We position it relative to our X + label_width
  field = std::make_unique<ValueField>(x + label_width, y, 80, 24, font, id,
                                       getter);
}

MetricRow::~MetricRow() {
  if (label_tex)
    SDL_DestroyTexture(label_tex);
  if (unit_tex)
    SDL_DestroyTexture(unit_tex);
}

void MetricRow::set_position(int new_x, int new_y) {
  x = new_x;
  y = new_y;
  // Update child position
  field->set_position(x + label_width, y);
}

void MetricRow::render_for_rider(const RenderContext* ctx,
                                 const RiderSnapshot* snap) {
  // 1. Render static labels once
  if (!label_tex) {
    SDL_Surface* s = TTF_RenderText_Blended(font, label_txt.c_str(), 0,
                                            {200, 200, 200, 255});
    label_tex = SDL_CreateTextureFromSurface(ctx->renderer, s);
    SDL_DestroySurface(s);
  }
  if (!unit_tex && !unit_txt.empty()) {
    SDL_Surface* s =
        TTF_RenderText_Blended(font, unit_txt.c_str(), 0, {150, 150, 150, 255});
    unit_tex = SDL_CreateTextureFromSurface(ctx->renderer, s);
    SDL_DestroySurface(s);
  }

  // 2. Draw Label (Left)
  if (label_tex) {
    float w, h;
    SDL_GetTextureSize(label_tex, &w, &h);
    // Vertically center label relative to the row height (approx 24)
    SDL_FRect r = {(float)x, (float)y + (24 - h) / 2, w, h};
    SDL_RenderTexture(ctx->renderer, label_tex, nullptr, &r);
  }

  // Call the specific render on the field
  field->render_with_snapshot(ctx, snap);

  if (unit_tex) {
    float w, h;
    SDL_GetTextureSize(unit_tex, &w, &h);
    // Position: X + label + field_width + padding
    SDL_FRect r = {(float)(x + label_width + field->get_width() + 5),
                   (float)y + (24 - h) / 2, w, h};
    SDL_RenderTexture(ctx->renderer, unit_tex, nullptr, &r);
  }
}

// ======================= RIDER PANEL =======================
// WARNING - this assumes the font isnt deallocated
RiderPanel::RiderPanel(int x_, int y_, TTF_Font* f) : x(x_), y(y_), font(f) {}

void RiderPanel::set_rider_id(int uid) { rider_uid = uid; }

RiderPanel::~RiderPanel() {
  if (title_tex)
    SDL_DestroyTexture(title_tex);
}

void RiderPanel::add_row(std::string label, std::string unit,
                         ValueField::DataGetter getter) {
  int row_height = 30;                                // height + spacing
  int current_offset = rows.size() * row_height + 30; // +30 for title space

  // pass 0 as dummy, we overrider it
  // Ideally, MetricRow should also be refactored, but here is a
  // quick inheritance trick:

  // Better yet, let's make MetricRow dynamic too.
  // But to save refactoring EVERYTHING, let's use a "Dynamic ID" constant?
  // No, cleaner to just pass the ID in render.
  auto row = std::make_unique<MetricRow>(x, y + current_offset, font, 0, label,
                                         unit, getter);
  rows.push_back(std::move(row));
}

void RiderPanel::render(const RenderContext* ctx) {

  const RiderSnapshot* snap = ctx->get_snapshot(rider_uid);
  if (!snap)
    return;

  std::string title_text = snap->name;

  if (title != title_text) {
    title = title_text;
    if (title_tex)
      SDL_DestroyTexture(title_tex);
    SDL_Surface* s =
        TTF_RenderText_Blended(font, title.c_str(), 0, {255, 255, 255});
    title_tex = SDL_CreateTextureFromSurface(ctx->renderer, s);
    SDL_DestroySurface(s);
  }
  // Draw Title
  if (!title_tex) {
    SDL_Surface* s = TTF_RenderText_Blended(font, title.c_str(), 0,
                                            {255, 255, 0, 255}); // Yellow title
    title_tex = SDL_CreateTextureFromSurface(ctx->renderer, s);
    SDL_DestroySurface(s);
  }

  float w, h;
  SDL_GetTextureSize(title_tex, &w, &h);
  SDL_FRect r = {(float)x, (float)y, w, h};
  SDL_RenderTexture(ctx->renderer, title_tex, nullptr, &r);

  // HACK for now: Iterate rows, find their internal fields, and update their
  // ID? Proper way: Refactor ValueField::render to take a snapshot, not look it
  // up itself.
  // Draw all rows
  for (auto& row : rows) {
    row->render_for_rider(ctx, snap);
  }
}
```

